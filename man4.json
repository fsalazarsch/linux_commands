[{"NOMBRE": "       console - terminal de consola y consolas virtuales.\n\n", "DESCRIPCI\u00d3N": "       Un sistema Linux tiene hasta 63 consolas virtuales (dispositivos de car\u00e1cter de n\u00famero mayor 4 y menor de\n       1 a 63), denominadas habitualmente /dev/ttyn donde 1 \u2264 n \u2264 63.  La consola actual se designa tambi\u00e9n  por\n       /dev/console  o  /dev/tty0,  el  dispositivo  de  car\u00e1cter con n\u00famero mayor 4 y menor 0.  Los ficheros de\n       dispositivo /dev/* se crean normalmente con el gui\u00f3n MAKEDEV o con mknod(1), habitualmente  con  el  modo\n       0622 y propietario/grupo root.tty.\n\n       Anteriormente  a  la versi\u00f3n 1.1.54 del n\u00facleo, el n\u00famero de consolas virtuales se compilaba en el propio\n       n\u00facleo (en tty.h: #define NR_CONSOLES 8) y s\u00f3lo se pod\u00eda cambiar editando y recompilando. A partir de  la\n       versi\u00f3n 1.1.54, las consolas virtuales se crean sobre la marcha, en el momento en que se necesiten.\n\n       Las  formas habituales de arrancar un proceso en una consola son: (a) decir a init(8) (en inittab(5)) que\n       arranque un getty(8) en la consola; (b) pedir a open(1) que  arranque  un  proceso  en  la  consola;  (c)\n       arrancar  X,  que  buscar\u00e1 la primera consola libre y visualizar\u00e1 all\u00ed su salida.  (Tambi\u00e9n est\u00e1 el viejo\n       doshell(8).)\n\n       Para conmutar de consola podemos: (a) teclear Alt+Fn o Ctrl+Alt+Fn para conmutar a la consola n; AltGr+Fn\n       puede  llevarnos  a  la  consola  n+12 [aqu\u00ed Alt y AltGr se refieren a las teclas Alt izquierda y derecha\n       respectivamente]; (b) usar Alt+CursorDerecha o Alt+CursorIzquierda para hacer un ciclo a  trav\u00e9s  de  las\n       consolas  en  uso;  (c)  usar  el  programa  chvt(1).  (Las combinaciones de teclas son definibles por el\n       usuario, v\u00e9ase loadkeys(1).  Las combinaciones mencionadas arriba son los valores por omisi\u00f3n).\n\n       El programa deallocvt(1) (anteriormente disalloc)  libera  la  memoria  reservada  por  los  tampones  de\n       pantalla de aquellas consolas que no tengan ning\u00fan proceso asociado.\n\n", "PROPIEDADES": "       Las  consolas  conllevan  un mont\u00f3n de estado. Espero documentarlo alguna vez. El hecho m\u00e1s importante es\n       que las consolas simulan terminales vt100. En particular, si se imprimen dos caracteres ESC c, la consola\n       vuelve a su estado inicial. Todas las secuencias de escape se pueden encontrar en console_codes(4).\n\n", "FICHEROS": "       /dev/console\n       /dev/tty*\n\nV\u00c9ASE TAMBI\u00c9N\n       chvt(1),  deallocvt(1),  loadkeys(1),  mknod(1),  open(1),  console_codes(4),  console_ioctl(4),  tty(4),\n       ttys(4), charsets(7), getty(8), init(8), mapscrn(8) resizecons(8), setfont(8)\n\nLinux                                             30 junio 1996                                       CONSOLE(4)\n"},{"NOMBRE": "       console_codes - secuencias de escape y control de la consola de Linux\n\n", "DESCRIPCI\u00d3N": "       La  consola  de  Linux  implementa  un  vasto  subconjunto de los controles de terminal de la VT102 y del\n       est\u00e1ndar ECMA-48/ISO 6429/ANSI X3.64, m\u00e1s ciertas secuencias de modo privadas para cambiar la  paleta  de\n       colores,  asociaciones  de  conjuntos de caracteres, etc.  En las descripciones tabulares de abajo, la 2\u00aa\n       columna da los mnem\u00f3nicos ECMA-48 o DEC (\u00e9stos, prefijados por DEC) para la funci\u00f3n dada.  Las secuencias\n       sin un mnem\u00f3nico no son ni ECMA-48 ni VT102.\n\n       Despu\u00e9s  de  haber hecho todo el procesamiento de salida normal, y de que un flujo de caracteres llega al\n       controlador de consola para la impresi\u00f3n de verdad, la 1\u00aa cosa que ocurre es una  traducci\u00f3n  del  c\u00f3digo\n       empleado para el procesamiento al c\u00f3digo empleado para la impresi\u00f3n.\n\n       Si  la consola est\u00e1 en el modo UTF-8, entonces los bytes que llegan se ensamblan 1\u00ba a los c\u00f3digos de 16 b\n       Unicode. Si no, cada byte se transforma seg\u00fan la tabla de asociaciones en curso  (que  lo  traduce  a  un\n       valor Unicode). Vea m\u00e1s abajo la secci\u00f3n CONJUNTOS DE CARACTERES para la discusi\u00f3n sobre esto.\n\n       En  el  caso  normal,  el  valor Unicode se convierte a un \u00edndice de tipo de letra, y \u00e9ste se almacena en\n       memoria de v\u00eddeo, de forma que aparezca en la pantalla el grafo correspondiente (seg\u00fan se encuentra en la\n       ROM  de  v\u00eddeo).  Observe que el empleo de Unicode (y el dise\u00f1o del hardware del PC) nos permite usar 512\n       grafos diferentes simult\u00e1neamente.\n\n       Si el valor actual Unicode es un car\u00e1cter de control, o estamos actualmente procesando una  secuencia  de\n       escape,  el  valor se tratar\u00e1 especialmente. En vez de convertirse a un \u00edndice de tipo y presentarse como\n       un grafismo, puede lanzar un movimiento del cursor u otra funci\u00f3n de control.  Vea la  secci\u00f3n  CONTROLES\n       DE LA CONSOLA DE LINUX abajo para la discusi\u00f3n sobre esto.\n\n       Generalmente  no es una buena idea codificar directamente controles de terminal en programas. Linux tiene\n       una base de datos terminfo(5) de capacidades de terminales.  En vez de emitir a mano secuencias de escape\n       de la consola, Ud. deber\u00eda casi siempre utilizar una biblioteca de pantalla que consultara terminfo o una\n       utilidad, como ncurses(3), tput(1), o reset(1).\n\nCONTROLES DE LA CONSOLA DE LINUX\n       Esta secci\u00f3n describe todos los caracteres de control y secuencias  de  escape  que  llaman  a  funciones\n       especiales  (i.e.,  cualquier  otra  cosa  distinta  a escribir un grafo en la localizaci\u00f3n del cursor en\n       curso) en la consola de Linux.\n\n   Caracteres de control\n       Un car\u00e1cter lo es de control si (antes de la transformaci\u00f3n seg\u00fan la tabla de asociaciones) tiene uno  de\n       los  14  c\u00f3digos  00  (NUL),  07 (BEL), 08 (BS), 09 (HT), 0a (LF), 0b (VT), 0c (FF), 0d (CR), 0e (SO), 0f\n       (SI), 18 (CAN), 1a (SUB), 1b (ESC), 7f (DEL).  Uno puede establecer un modo  de  `mostrar  caracteres  de\n       control' (vea m\u00e1s abajo), y permitir que los c\u00f3digos 07, 09, 0b, 18, 1a, 7f se muestren como grafos.  Por\n       otro lado, en modo UTF-8 todos los c\u00f3digos 00-1f se miran como caracteres de control, sin importar ning\u00fan\n       modo `mostrar caracteres de control'.\n\n       Si  tenemos  un car\u00e1cter de control, se act\u00faa inmediatamente y luego se descarta (incluso en medio de una\n       secuencia de escape) y la secuencia de escape contin\u00faa con el  siguiente  car\u00e1cter.   (Sin  embargo,  ESC\n       empieza  una  nueva  secuencia  de  escape,  posiblemente  abortando una anterior no acabada, y CAN y SUB\n       abortan cualquier secuencia de escape).  Los caracteres de control reconocidos son BEL, BS, HT,  LF,  VT,\n       FF, CR, SO, SI, CAN, SUB, ESC, DEL, CSI. Hacen lo que uno esperar\u00eda:\n\n       BEL (0x07, ^G) pita;\n\n       BS (0x08, ^H) va un espacio atr\u00e1s a la columna anterior (pero no pasa del principio de la l\u00ednea);\n\n       HT (0x09, ^I) va a la siguiente parada de tabulaci\u00f3n o al final de la l\u00ednea si no hay antes una parada de\n              tabulaci\u00f3n;\n\n       LF (0x0A, ^J), VT (0x0B, ^K) y FF (0x0C, ^L) todos dan un salto de l\u00ednea;\n\n       CR (0x0D, ^M) da un retorno de carro;\n\n       SO (0x0E, ^N) activa el conjunto de caracteres G1, y si  est\u00e1  activado  LF/NL  (modo  de  nueva  l\u00ednea),\n              tambi\u00e9n un retorno de carro;\n\n       SI (0x0F, ^O) activa el conjunto de carcteres G0;\n\n       CAN (0x18, ^X) y SUB (0x1A, ^Z) interrumpen secuencias de escape;\n\n       ESC (0x1B, ^[) empieza una secuencia de escape;\n\n       DEL (0x7F) no es tenido en cuenta;\n\n       CSI (0x9B) es equivalente a ESC [.\n\n   Secuencias de ESC, pero no CSI\n       ESC c     RIS      Inicio.\n       ESC D     IND      Salto de l\u00ednea.\n       ESC E     NEL      Nueva l\u00ednea.\n       ESC H     HTS      Pone parada tab en esta columna.\n       ESC M     RI       Salto de l\u00ednea inverso.\n       ESC Z     DECID    DEC identificaci\u00f3n privada. El n\u00facleo\n                          devuelve la cadena ESC [ ? 6 c, diciendo\n                          que es una VT102.\n       ESC 7     DECSC    Salva el estado actual (cordenadas del cursor,\n                          atributos, conjuntos de caracteres apuntados por G0, G1).\n       ESC 8     DECRC    Restaura el estado salvado m\u00e1s reciente por ESC 7.\n       ESC [     CSI      Introductor de secuencia de control\n       ESC %              Empieza la secuencia de selecci\u00f3n de conjunto de caracteres\n       ESC % @               Selecciona el predeterminado (ISO 646 / ISO 8859-1)\n       ESC % G               Selecciona UTF-8\n       ESC % 8               Selecciona UTF-8 (obsoleto)\n       ESC # 8   DECALN   DEC prueba de alineaci\u00f3n en pantalla - la llena de E's.\n       ESC (              Empieza secuencia de definici\u00f3n del conjunto G0\n       ESC ( B               Selecciona predeterminado (asociaci\u00f3n ISO 8859-1)\n       ESC ( 0               Selecciona asociaci\u00f3n de gr\u00e1ficos vt100\n       ESC ( U               Selecciona ninguna asociaci\u00f3n - derecho a la ROM\n       ESC ( K               Selecciona asociaci\u00f3n del usuario - la que se carga con\n                             la utilidad mapscrn(8).\n       ESC )              Empieza la secuencia de definici\u00f3n de G1\n                          (seguido por uno de B, 0, U, K, como arriba).\n       ESC >     DECPNM   Pone el teclado auxiliar en modo num\u00e9rico\n       ESC =     DECPAM   Pone el teclado auxiliar en modo aplicaci\u00f3n\n       ESC ]     OSC      (Deber\u00eda ser: Orden del sistema operativo)\n                          ESC ] P nrrggbb: pone paleta, con par\u00e1metro\n                          dado en 7 d\u00edgitos hexadecimales tras la P final :-(.\n                          Aqu\u00ed n es el color (0-15), y rrggbb indica\n                          los valores rojo/verde/azul (0-255).\n                          ESC ] R: restaura paleta\n\n   Secuencias ECMA-48 CSI\n       CSI  (o  ESC  [)  es  seguido  por una secuencia de par\u00e1metros, como mucho NPAR (16), que son los n\u00fameros\n       decimales separados por punto y comas. Un par\u00e1metro vac\u00edo o ausente se toma  como  0.   La  secuencia  de\n       par\u00e1metros puede ir precedida por un signo de interrogaci\u00f3n.\n\n       Sin  embargo,  tras  CSI  [  (o  ESC [ [) se lee un car\u00e1cter solo y esta secuencia entera no es tenida en\n       cuenta. (La idea es no hacer caso de una tecla de funci\u00f3n que se muestra.)\n\n       La acci\u00f3n de una secuencia CSI se determina por su car\u00e1cter final.\n\n       @   ICH       Insertar el N\u00ba indicado de caracteres blancos\n       A   CUU       Mover cursor arriba el N\u00ba indicado de filas\n       B   CUD       Mover cursor abajo el N\u00ba indicado de filas\n       C   CUF       Mover cursor a la derecha el N\u00ba indicado de columnas\n\n       D   CUB       Mover cursor a la izquierda el N\u00ba indicado de columnas\n       E   CNL       Mover cursor abajo el N\u00ba indicado de filas, a la columna 1\n       F   CPL       Mover cursor arriba el N\u00ba indicado de filas, a la columna 1\n       G   CHA       Mover cursor a la columna indicada en la fila actual\n       H   CUP       Mover cursor a la fila y columna indicadas (origen en 1,1)\n       J   ED        Borrar pantalla (p. o.: desde el cursor al final de la pantalla).\n                     ESC [ 1 J: borrar desde el comienzo hasta el cursor.\n                     ESC [ 2 J: borrar la pantalla entera.\n       K   EL        Borrar l\u00ednea (p.o.: desde el cursor al final de la l\u00ednea).\n                     ESC [ 1 K: borrar desde el comienzo de la l\u00ednea al cursor\n                     ESC [ 2 K: borrar la l\u00ednea entera.\n       L   IL        Insertar el N\u00ba indicado de l\u00edneas en blanco\n       M   DL        Borrar el N\u00ba indicado de l\u00edneas\n       P   DCH       Borrar el N\u00ba indicado de caracteres en la l\u00ednea actual\n       X   ECH       Borrar el N\u00ba indicado de caracteres en la l\u00ednea actual\n       a   HPR       Mover cursor a la derecha el N\u00ba indicado de columnas\n       c   DA        Reponder ESC [ ? 6 c: `Yo soy una VT102'.\n       d   VPA       Mover cursor a la fila y columna indicadas\n       e   VPR       Mover cursor abajo el N\u00ba indicado de filas\n       f   HVP       Mover cursor a la fila y columna indicadas\n       g   TBC       Sin par\u00e1metro: quita parada TAB en la posici\u00f3n actual\n                     ESC [ 3 g: borra todas las paradas de tabulaci\u00f3n\n       h   SM        Establece Modo (vea abajo).\n       l   RM        Restablece Modo (vea abajo).\n       m   SGR       Establece atributos (vea abajo).\n       n   DSR       Informe de estado (vea abajo).\n       q   DECLL     Establece los LEDs del teclado.\n                     ESC [ 0 q: apaga todos los LEDs\n                     ESC [ 1 q: pone LED Bloq. Despl.\n                     ESC [ 2 q: pone LED Bloq. Num.\n                     ESC [ 3 q: pone LED Bloq. May\u00fas.\n       r   DECSTBM   Establece regi\u00f3n de rodadura; los par\u00e1metros son la fila de arriba y abajo\n       s   ?         Salva la localizaci\u00f3n del cursor\n       u   ?         Restaura la localizaci\u00f3n del cursor.\n       `   HPA       Mover cursor a la columna indicada en la fila indicada\n\n   ECMA-48 Pone modo Gr\u00e1fico\n       La secuencia ECMA-48 SGR  ESC [ <par\u00e1metros> m establece los atributos de la pantalla.  Se  pueden  poner\n       varios atributos en la misma secuencia.\n\n       par   resultado\n       0     restablece todos los atributos a sus valores predeterminados\n       1     pone negrillas\n       2     pone medio brillo (simulado con color en una pantalla a color)\n       4     pone subrayado (simulado con color en una pantalla a color)\n             (los colores para simular disminuci\u00f3n o subrayado se ponen con\n             ESC ] ...)\n       5     pone intermitencia\n       7     pone v\u00eddeo inverso\n       10    restaura asociaci\u00f3n seleccionada, indicador de control de\n             pantalla y cambia el indicador meta\n       11    selecciona no asociaci\u00f3n, pone indicador de control de\n             pantalla, restaura indicador de cambio meta\n       12    selecciona no asociaci\u00f3n, pone indicador de control de\n             pantalla, pone indicador de cambio meta (que hace que el bit\n             m\u00e1s alto de un byte cambie antes de que se haga la traducci\u00f3n\n             de la tabla de asociaci\u00f3n.)\n       21    pone intensidad normal (esto no es compatible con ECMA-48)\n       22    pone intensidad normal\n       24    quita subrayado\n       25    quita intermitencia\n       27    quita v\u00eddeo inverso\n       30    pone negro\n       31    pone rojo\n       32    pone verde\n\n       33    pone marr\u00f3n\n       34    pone azul\n       35    pone rosa\n       36    pone celeste\n       37    pone blanco\n       38    pone subrayado, color predeterminado\n       39    quita subrayado, pone color predeterminado\n       40    pone negro de fondo\n       41    pone rojo de fondo\n       42    pone verde de fondo\n       43    pone marr\u00f3n de fondo\n       44    pone azul de fondo\n       45    pone rosa de fondo\n       46    pone celeste de fondo\n       47    pone blanco de fondo\n       49    pone el color de fondo predeterminado\n\n   Interruptores de Modo ECMA-48\n       ESC [ 3 h\n              DECCRM (por omisi\u00f3n desactivado): Mostrar caracteres de control\n\n       ESC [ 4 h\n              DECIM (por omisi\u00f3n desactivado): Poner modo de inserci\u00f3n\n\n       ESC [ 20 h\n              LF/NL (por omisi\u00f3n desactivado): Autom\u00e1ticamente seguir a LF, VT o FF con CR.\n\n   \u00d3rdenes de Informe de Estado ECMA-48\n       ESC [ 5 n\n              Informe de estado de dispositivo (DSR): La respuesta es ESC [ 0 n (Terminal OK).\n\n       ESC [ 6 n\n              Informe  de  posici\u00f3n de cursor (CPR): La respuesta es ESC [ y ; x R, donde x,y es la localizaci\u00f3n\n              del cursor.\n\n   Secuencias de Modo Privado DEC (DECSET/DECRST).\n       \u00c9stas no se describen en ECMA-48. Listamos las secuencias de Establecer Modo; las de Reestablecer Modo se\n       obtienen reemplazando la hache final por ele.\n\n       ESC [ ? 1 h\n              DECCKM  (por  omisis\u00f3n  desactivado): Cuando est\u00e1 activado, las teclas de cursor env\u00edan un prefijo\n              ESC O, en vez de ESC [.\n\n       ESC [ ? 3 h\n              DECCOLM (por omisi\u00f3n desactivado = 80 columnas): interruptor de  modo  80/132  columnas.   En  los\n              fuentes  del  controlador  se  hace  notar que esto solo no basta; alguna utilidad de usuario como\n              resizecons(8) tiene que cambiar los registros de hardware en la tarjeta de v\u00eddeo de consola.\n\n       ESC [ ? 5 h\n              DECSCNM (por omisi\u00f3n desactivado): Pone el modo de v\u00eddeo inverso\n\n       ESC [ ? 6 h\n              DECOM (por omisi\u00f3n desactivado): Cuando est\u00e1 activado, el direccionamiento del cursor es  relativo\n              a la esquina superior izquierda de la regi\u00f3n de rodadura.\n\n       ESC [ ? 7 h\n              DECAWM  (por  omisi\u00f3n  activado):  Activa el paso autom\u00e1tico de rengl\u00f3n. En este modo, un car\u00e1cter\n              gr\u00e1fico emitido tras la columna 80 (o la 132  si  est\u00e1  activado  DECCOLM)  fuerza  un  cambio  al\n              principio de la siguiente l\u00ednea.\n\n       ESC [ ? 8 h\n              DECARM (por omisi\u00f3n activado): Activa la auto-repetici\u00f3n del teclado\n\n       ESC [ ? 9 h\n              Informe  de Rat\u00f3n X10 (por omisi\u00f3n desactivado): Establece el modo de informe a 1 (o lo restaura a\n              0) - vea abajo.\n\n       ESC [ ? 25 h\n              DECCM (por omisi\u00f3n activado): Hace visible el cursor.\n\n       ESC [ ? 1000 h\n              Informe de Rat\u00f3n X11 (por omisi\u00f3n desactivado): Establece el modo de informe a 2 (o lo restaura  a\n              0) - vea abajo.\n\n   Secuencias Privadas de Consola de Linux CSI\n       Las  siguientes  secuencias  no son ni ECMA-48 ni VT102 nativas. Son nativas al controlador de consola de\n       Linux. Los colores est\u00e1n en los par\u00e1metros SGR: 0 = negro, 1 = rojo, 2 = verde, 3 = marr\u00f3n, 4 = azul, 5 =\n       rosa, 6 = celeste, 7 = blanco.\n\n       ESC [ 1 ; n ]       Pone el color n como el de subrayado\n       ESC [ 2 ; n ]       Pone el color n como el disminuido\n       ESC [ 8 ]           Hace al color actual el de los atributos predeterminados\n       ESC [ 9 ; n ]       Pone el tiempo de espera del blanqueado de la terminal a n min.\n       ESC [ 10 ; n ]      Establece la frecuencia del pito en Hz.\n       ESC [ 11 ; n ]      Establece la duraci\u00f3n del pitido en ms.\n       ESC [ 12 ; n ]      Trae al frente la consola especificada.\n       ESC [ 13 ]          Quita el blanco de la pantalla.\n       ESC [ 14 ; n ]      Establece el intervalo de apagado VESA en min.\n\nCONJUNTOS DE CARACTERES\n       El n\u00facleo sabe de 4 traducciones de bytes a s\u00edmbolos de la pantalla de la consola. Las cuatro tablas son:\n       a) Latin1 -> PC,  b) gr\u00e1ficos VT100 -> PC, c) PC -> PC, d) definida por el usuario.\n\n       Hay dos conjuntos de caracteres, llamados G0 y G1, y uno de ellos es el actual. (Inicialmente G0.)\n\n       Teclear ^N hace que G1 sea el actual, ^O hace a G0 el actual.\n\n       Estas variables G0 y G1 apuntan a una tabla de  traducci\u00f3n,  y  pueden  ser  cambiadas  por  el  usuario.\n       Inicialmente  apuntan a las tablas a) y b) respectivamente.  Las secuencias ESC ( B y ESC ( 0 y ESC ( U y\n       ESC ( K causan que G0 apunte a la tabla a), b), c) y d) respectivamente.  Las secuencias ESC ) B y ESC  )\n       0 y ESC ) U y ESC ) K causan que G1 apunte a la tabla a), b), c) y d), respectivamente.\n\n       La  secuencia ESC c provoca una puesta a cero de la terminal, que es lo que uno quiere cuando la pantalla\n       est\u00e1 liada. El otrora truco \"echo ^V^O\" solamente hace G0 actual, pero no hay garant\u00edas de que G0  apunte\n       a  la  tabla a).  En algunas distribuciones hay un programa reset(1) que simplemente hace \"echo ^[c\".  Si\n       su entrada de terminfo para la consola es correcto (y tiene una entrada rs1=\\Ec), entonces  \"tput  reset\"\n       tambi\u00e9n funcionar\u00e1.\n\n       La  tabla  de  asociaci\u00f3n  definida  por  el  usuario  puede  ponerse con mapscrn(8).  El resultado de la\n       asociaci\u00f3n es que si hay un s\u00edmbolo c que se imprime, se env\u00eda a la memoria  de  v\u00eddeo  el  s\u00edmbolo  s  =\n       map[c].  El  mapa  de  bits  que  corresponde a s se encuentra en la ROM de caracteres, y puede cambiarse\n       mediante setfont(8).\n\nPISTA DEL RAT\u00d3N\n       La facilidad de seguimiento de pista  del  rat\u00f3n  sirve  para  devolver  informes  de  estado  del  rat\u00f3n\n       compatibles  con  xterm. Puesto que el controlador de consola no tiene forma de conocer el dispositivo ni\n       tipo del rat\u00f3n, estos informes se devuelven en el  flujo  de  entrada  de  la  consola  s\u00f3lo  cuando  del\n       controlador  de  terminal  virtual  recibe  un  ioctl  de  actualizaci\u00f3n de rat\u00f3n. Estos ioctls deben ser\n       generados por una aplicaci\u00f3n de usuario que haga uso del rat\u00f3n como el duende gpm(8).\n\n       Los par\u00e1metros para todas las secuencias de escape de pista del rat\u00f3n generadas por xterm  codifican  los\n       par\u00e1metros  num\u00e9ricos  en  un  simple  car\u00e1cter  como  valor+040.   Por ejemplo, `!' es 1.  El sistema de\n       coordenadas de la pantalla empieza en 1.\n\n       El modo de compatibilidad X10 env\u00eda una secuencia de escape cuando  se  pulsa  un  bot\u00f3n  codificando  la\n       localizaci\u00f3n  y el bot\u00f3n del rat\u00f3n pulsado.  Esto se activa enviando ESC [ ? 9 h y se desactiva con ESC [\n       ? 9 l.  Cuando se pulsa un bot\u00f3n, xterm env\u00eda ESC [ M bxy (6 caracteres).  Aqu\u00ed b es bot\u00f3n-1, y x y y son\n       las  coordenadas x e y del rat\u00f3n cuando se puls\u00f3 el bot\u00f3n.  Esto es el mismo c\u00f3digo que el n\u00facleo tambi\u00e9n\n       produce.\n\n       El modo de pista normal (no implementado en Linux 2.0.24) env\u00eda una secuencia de escape cuando se pulas o\n       se libera un bot\u00f3n. Tambi\u00e9n se env\u00eda informaci\u00f3n de modificador. Se habilita enviando ESC [ ? 1000 h y se\n       inhabilita con ESC [ 1000 l.  Cuando se pulas o libera un bot\u00f3n, xtermenv\u00eda ESC [ M bxy.   Los  dos  bits\n       bajos  de b codifican informaci\u00f3n del bot\u00f3n: 0=MB1 pulsado, 1=MB2 pulsado, 2=MB3 pulsado, 3=liberar.  Los\n       bits m\u00e1s altos codifican qu\u00e9 modificadores estaban pulsados cuando el  bot\u00f3n  se  hubo  presionado  y  se\n       a\u00f1aden  juntos: 4=May\u00fasculas, 8=Meta, 16=Control.  De nuevo x e y son las coordenadas x e y del evento de\n       rat\u00f3n. La esquina superior izquierda es (1,1).\n\nCOMPARACIONES CON OTRAS TERMINALES\n       Muchos tipos diferentes de terminal se describen, como la consola de  Linux,  como  `compatibles  VT100'.\n       Aqu\u00ed  se  discuten las diferencias entre la consola de Linux y las otras dos m\u00e1s importantes, la VT102 de\n       DEC y la xterm(1).\n\n   Manejo de caracteres de control\n       La vt102 tambi\u00e9n reconoc\u00eda los siguientes caracteres de control:\n\n       NUL (0x00) no era tenido en cuenta;\n\n       ENQ (0x05) lanzaba un mensaje de reconocimiento;\n\n       DC1 (0x11, ^Q, XON) reanudaba la transmisi\u00f3n;\n\n       DC3 (0x13, ^S, XOFF) hac\u00eda que la vt100 no tuviera en cuenta (y  parara  la  transmisi\u00f3n)  ning\u00fan  c\u00f3digo\n              excepto XOFF y XON.\n\n       El controlador de tty puede habilitar el procesamiento de DC1/DC3 al estilo de la VT100.\n\n       El programa xterm (en modo vt100) reconoce los caracteres de control BEL, BS, HT, LF, VT, FF, CR, SO, SI,\n       ESC.\n\n   Secuencias de Escape\n       Secuncias de consola VT100 no implementadas en la consola de Linux:\n\n       ESC N       SS2   Simple cambio 2. (Selecciona el conjunto de caracteres\n                         G2 s\u00f3lo para el sgute. car\u00e1cter.)\n       ESC O       SS3   Simple cambio 3. (Selecciona el conjunto de caracteres\n                         G3 s\u00f3lo para el sgute. car\u00e1cter.)\n       ESC P       DCS   Cadena de control de dispositivo (acabada por ESC \\)\n       ESC X       SOS   Comienzo de cadena.\n       ESC ^       PM    Mensaje de privacidad (acabado por ESC \\)\n       ESC \\       ST    Terminador de caadena\n       ESC * ...         Designa el conjunto de caracteres G2\n       ESC + ...         Designa el conjunto de caracteres G3\n\n       El programa xterm (en modo vt100) reconoce ESC c, ESC # 8, ESC >, ESC =, ESC D, ESC E, ESC H, ESC M,  ESC\n       N,  ESC  O,  ESC  P  ...  ESC    ESC  Z  (responde ESC [ ? 1 ; 2 c, `Yo soy una vt100 con opci\u00f3n de v\u00eddeo\n       avanzado') y ESC ^ ... ESC  con los mismos significados que los arriba indicados.  Acepta ESC (,  ESC  ),\n       ESC  *,  ESC + seguidos por  0, A, B para el conjunto de caracteres especiales y l\u00edneas de dibujo de DEC,\n       UK y US-ASCII, respectivamente.  Acepta ESC ] para el establecimiento de ciertos recursos:\n\n       ESC ] 0 ; txt BEL     Pone nombre de icono y t\u00edtulo de ventana como txt.\n       ESC ] 1 ; txt BEL     Pone txt como nombre de icono.\n       ESC ] 2 ; txt BEL     Pone txt como t\u00edtulo de ventana.\n       ESC ] 4 6 ; log BEL   Cambia el nombre del fichero de registro a log\n                             (normalmente deshabilitado por una opci\u00f3n de tiempo de\n                             compilaci\u00f3n)\n       ESC ] 5 0 ; fn BEL    Pone fn como el tipo de letra.\n\n       Reconoce lo siguiente con un significado ligeramente modificado:\n\n       ESC 7  DECSC   Salva el cursor\n       ESC 8  DECRC   Restaura el cursor\n\n       Tambi\u00e9n reconoce\n\n       ESC F          Cursor a esquina inferior izda. de la pantalla (si\n                      permitido por el recurso hpLowerleftBugCompat)\n       ESC l          Bloqueo de memoria (por terminales HP).\n                      Bloquea la memoria sobre el cursor.\n       ESC m          Desbloqueo de memoria (por terminales HP).\n       ESC n   LS2    Invoca el conjunto de caracteres G2.\n       ESC o   LS3    Invoca el conjunto de caracteres G2.\n       ESC |   LS3R   Invoca el conjunto de caracteres G3 como GR.\n                      No tiene efecto visible en xterm.\n       ESC }   LS2R   Invoca el conjunto de caracteres G2 como GR.\n                      No tiene efecto visible en xterm.\n       ESC ~   LS1R   Invoca el conjunto de caracteres G1 como GR.\n                      No tiene efecto visible en xterm.\n\n       No reconoce ESC % ...\n\n   Secuencias CSI\n       El programa xterm (en XFree86 3.1.2G) no reconoce los  SGRs  de  modo  invisible  o  parpadeo.  Versiones\n       originales  X11R6 no reconocen los SGRs de establecimiento de colores.  Todas las otras secuencias CSI de\n       ECMA-48 reconocidas por Linux tambi\u00e9n lo son por xterm, y viceversa.\n\n       El programa xterm reconocer\u00e1 todas las secuencias de Modo Privado de DEC listadas arriba, pero ninguna de\n       las secuencias de modo privado de Linux.  Para una discusi\u00f3n sobre las propias secuencias de modo privado\n       de xterm, refi\u00e9rase al documento Xterm Control Sequences por Edward Moy & Stephen Gildea, disponible  con\n       la distribuci\u00f3n X-Window.\n\n", "FALLOS": "       En 2.0.23, CSI no funciona, y NUL es tenido en cuenta dentro de secuencias de escape.\n\nV\u00c9ASE TAMBI\u00c9N\n       console(4), console_ioctl(4), charsets(7)\n\nLinux                                            31 octubre 1996                                CONSOLE_CODES(4)\n"},{"NOMBRE": "       console ioctl - ioctl's para la terminal de consola y consolas virtuales\n\n", "DESCRIPCI\u00d3N": "       Se admiten las siguientes peticiones ioctl() peculiares de Linux.  Cada una requiere un tercer argumento,\n       supuesto aqu\u00ed como argp.\n\n       KDGETLED\n              Obtiene estado de los LEDs.  argp apunta a un long int.  Los 3 bits m\u00e1s bajos de  *argp  se  ponen\n              seg\u00fan el estado de los LEDs, como sigue:\n\n                  LED_CAP       0x04   LED Bloq. May\u00fas\n                  LEC_NUM       0x02   LED Bloq. Num\n                  LED_SCR       0x01   LED Bloq. Despl\n\n       KDSETLED\n              Enciende  los LEDs.  Los LEDs se encienden seg\u00fan los 3 bits m\u00e1s bajos de argp.  Sin embargo, si se\n              pone un bit de m\u00e1s alto orden, los LEDs se ponen a su funcionamiento normal: mostrar el estado  de\n              las   funciones   del   teclado:  bloqueo  de  may\u00fasculas,  de  teclado  auxiliar  num\u00e9rico  y  de\n              desplazamiento.\n\n       Antes de 1.1.54, los LEDs simplemente reflejaban el estado de las correspondientes se\u00f1ales del teclado, y\n       KDGETLED/KDSETLED  tamib\u00e9n  cambiaban  las  se\u00f1ales  del  teclado.  Desde 1.1.54, los LEDs pueden mostrar\n       informaci\u00f3n arbitraria, pero por omisi\u00f3n muestran las se\u00f1ales del teclado. Las 2  siguientes  llamadas  a\n       ioctl se usan para acceder a las se\u00f1ales del teclado.\n\n       KDGKBLED\n              Obtiene  las  se\u00f1ales del teclado Bloq.May\u00fas, BloqNum, BloqDespl (no las luces).  argp apunta a un\n              char que se pone con el estado de la se\u00f1al.  Los 3 bits de m\u00e1s bajo orden (m\u00e1scara  0x7)  obtienen\n              el estado de la se\u00f1al actual, y los bits de m\u00e1s bajo orden de la siguiente cuarteta (m\u00e1scara 0x70)\n              obtienen el estado de la se\u00f1al predeterminado. (Desde 1.1.54.)\n\n       KDSKBLED\n              Pone las se\u00f1ales del teclado Bloq.May\u00fas, BloqNum, BloqDespl (no las luces).  argp tiene el  estado\n              de  la  se\u00f1al deseado.  Los 3 bits de m\u00e1s bajo orden (m\u00e1scara 0x7) tienen el estado de la se\u00f1al, y\n              los bits de m\u00e1s bajo orden de la siguiente cuarteta (m\u00e1scara 0x70) tienen el estado  de  la  se\u00f1al\n              predeterminado. (Desde 1.1.54.)\n\n       KDGKBTYPE\n              Obtiene el tipo de teclado. Esto devuelve el valor KB_101, definido como 0x02.\n\n       KDADDIO\n              A\u00f1ade puerto de E/S como v\u00e1lido. Equivale a ioperm(arg,1,1).\n\n       KDDELIO\n              Quita puerto de E/S como v\u00e1lido. Equivale a ioperm(arg,1,0).\n\n       KDENABIO\n              Habilita E/S a la tarjeta de v\u00eddeo. Equivale a ioperm(0x3b4, 0x3df-0x3b4+1, 1).\n\n       KDDISABIO\n              Inhabilita la E/S a la tarjeta de v\u00eddeo. Equivale a ioperm(0x3b4, 0x3df-0x3b4+1, 0).\n\n       KDSETMODE\n              Pone el modo de texto o gr\u00e1fico.  argp es uno de \u00e9stos:\n\n                  KD_TEXT       0x00\n                  KD_GRAPHICS   0x01\n\n       KDGETMODE\n              Obtiene el modo de texto o gr\u00e1fico.  argp apunta a un long int que se pone a uno de los valores de\n              arriba.\n\n       KDMKTONE\n              Genera un tono de la longitud especificada.  Los 16 bits m\u00e1s bajos de argp especifican el  periodo\n              en ciclos de reloj, y los 16 bits m\u00e1s altos dan la duraci\u00f3n en ms.  Si la duraci\u00f3n es 0, el sonido\n              se apaga.  Se devuelve  el  control  inmediatamente.   Por  ejemplo,  argp  =  (125<<16)  +  0x637\n              especificar\u00eda  el  pitido  asociado normalmente con un Ctrl-G.  (Este modo de funcionamiento desde\n              0.99pl1; infringido en 2.1.49-50.)\n\n       KIOCSOUND\n              Empieza o para la generaci\u00f3n de sonido. Los 16 b m\u00e1s bajos  de  argp  especifican  el  periodo  en\n              ciclos  de  reloj  (esto  es, argp = 1193180\u00f7frecuencia).  argp = 0 apaga el sonido.  En cualquier\n              caso, se devuelve el control inmediatamente.\n\n       GIO_CMAP\n              Obtiene el mapa de colores predeterminado actual del n\u00facleo.  argp apunta a un vector de 48 bytes.\n              (Desde 1.3.3.)\n\n       PIO_CMAP\n              Cambia  el  mapa  de  colores  predeterminado  en  modo texto. argp apunta a un vector de 48 B que\n              contiene, en orden, los valores de Rojo,  Verde  y  Azul  para  los  16  colores  de  la  pantalla\n              sisponibles:  0  es  apagado,  y  255  es intensidad completa. Los colores predeterminados son, en\n              orden, negro, rojo oscuro, verde oscuro, marr\u00f3n, azul oscuro, p\u00farpura oscuro, celeste oscuro, gris\n              claro,  gris oscuro, rojo brillante, verde brillante, amarillo, azul brillante, p\u00farpura brillante,\n              celeste brillante y blanco. (Desde 1.3.3.)\n\n       GIO_FONT\n              Obtiene el tipo de letra de pantalla de 256 caracteres en forma expandida. argp apunta a un vector\n              de  8192  B.  Falla  con  el  c\u00f3digo  de error EINVAL si el tipo cargado actualmente es uno de 512\n              caracteres, o si la consola no est\u00e1 en modo texto.\n\n       GIO_FONTX\n              Obtiene el tipo de letra de  la  pantalla  e  informaci\u00f3n  asociada.  argp  apunta  a  una  struct\n              consolefontdesc  (vea  PIO_FONTX).   En el momento de la llamada, el campo charcount deber\u00eda estar\n              puesto con el m\u00e1ximo n\u00famero de caracteres que cupieran en el  b\u00fafer  apuntado  por  chardata.   Al\n              regresar,  los  campos  charcount  y  charheight  se llenan con los datos respectivos para el tipo\n              cargado actualmente, y el vector chardata contiene los datos del  tipo  si  el  valor  inicial  de\n              charcount  indicaba que hab\u00eda espacio suficiente disponible; de otra forma, el b\u00fafer queda intacto\n              y en errno se pone el valor ENOMEM. (Desde 1.3.1.)\n\n       PIO_FONT\n              Establece el tipo de letra de pantalla de 256  caracteres.  Carga  el  tipo  en  el  generador  de\n              caracteres  EGA/VGA.   argp  apunta  a un mapa de 8192 bytes, con 32 bytes por car\u00e1cter.  S\u00f3lo los\n              primeros N de ellos se emplean para un tipo de 8\u00d7N (0 < N <= 32).  Esta llamada  tambi\u00e9n  invalida\n              la asociaci\u00f3n Unicode.\n\n       PIO_FONTX\n              Establece el tipo de pantalla e informaci\u00f3n asociada de atributos de v\u00eddeo. argp apunta a una\n\n              struct consolefontdesc {\n                      u_short charcount;      /* caracteres en el tipo (256 \u00f3 512) */\n                      u_short charheight;     /* l\u00edneas de rastreo por car\u00e1cter (1-32) */\n                      char *chardata;         /* datos de tipo en forma expandida */\n              };\n\n              Si  es  necesario,  la  pantalla  se  redimensionar\u00e1  apropiadamente,  y se enviar\u00e1 SIGWINCH a los\n              procesos apropiados. Esta llamada tambi\u00e9n invalida la asociaci\u00f3n Unicode. (Desde 1.3.1.)\n\n       PIO_FONTRESET\n              Restaura el tipo de  letra  de  pantalla,  el  tama\u00f1o  y  la  asociaci\u00f3n  Unicode  a  los  valores\n              predeterminados  en  el  arranque.  No  se  usa  argp, pero debe igualarse a NULL para asegurar la\n              compatibilidad con versiones futuras de Linux. (Desde 1.3.28.)\n\n       GIO_SCRNMAP\n              Obtiene del n\u00facleo la asociaci\u00f3n de pantalla. argp apunta a un \u00e1rea  de  tama\u00f1o  E_TABSZ,  que  se\n              carga en las posiciones del tipo usadas para mostrar cada car\u00e1cter. Esta llamada m\u00e1s bien devuelve\n              informaci\u00f3n in\u00fatil si el tipo de letra cargado en la actualidad es de m\u00e1s de 256 caracteres.\n\n       GIO_UNISCRNMAP\n              Obtiene del n\u00facleo la asociaci\u00f3n de pantalla completa Unicode. argp apunta a  un  \u00e1rea  de  tama\u00f1o\n              E_TABSZ*sizeof(unsigned  short),  que  se carga con los Unicodes que representan cada car\u00e1cter. Se\n              usa un conjunto  especial  de  Unicodes,  empezando  por  U+F000,  para  representar  asociaciones\n              ``directas al tipo''. (Desde 1.3.1.)\n\n       PIO_SCRNMAP\n              Carga  la  (4\u00aa)  tabla ``definible por el usuario'' en el n\u00facleo, que asocia bytes con s\u00edmbolos de\n              pantalla de la consola. argp apunta a un \u00e1rea de tama\u00f1o E_TABSZ.\n\n       PIO_UNISCRNMAP\n              Carga en el n\u00facleo la (4\u00aa) tabla ``definible por el usuario'', que asocia bytes con Unicodes,  que\n              luego se traducen a s\u00edmbolos de la pantalla seg\u00fan el mapa cargado en la actualidad Unicode-a-tipo.\n              Los Unicodes especiales que empiezan en U+F000 se pueden usar  para  asociar  directamente  a  los\n              s\u00edmbolos del tipo. (Desde 1.3.1.)\n\n       GIO_UNIMAP\n              Obtiene del n\u00facleo la asocaci\u00f3n Unicode-a-tipo.  argp apunta a una\n\n              struct unimapdesc {\n                      u_short entry_ct;\n                      struct unipair *entries;\n              };\n\n              donde entries apunta a un vector de\n\n              struct unipair {\n                      u_short unicode;\n                      u_short fontpos;\n              };\n\n              (Desde 1.1.92.)\n\n       PIO_UNIMAP\n              Poner  la  asociaci\u00f3n  Unicode-a-tipo  en  el n\u00facleo. argp apunta a una struct unimapdesc.  (Desde\n              1.1.92)\n\n       PIO_UNIMAPCLR\n              Limpia la tabla, posiblemente informa al algoritmo de hash. argp apunta a una\n\n              struct unimapinit {\n                      u_short advised_hashsize;  /* 0 si no opini\u00f3n */\n                      u_short advised_hashstep;  /* 0 si no opini\u00f3n */\n                      u_short advised_hashlevel; /* 0 si no opini\u00f3n */\n              };\n\n              (Desde 1.1.92.)\n\n       KDGKBMODE\n              Obtiene el modo de teclado en curso. argp apunta a un long int que toma una de estos valores:\n\n                  K_RAW         0x00\n                  K_XLATE       0x01\n                  K_MEDIUMRAW   0x02\n                  K_UNICODE     0x03\n\n       KDSKBMODE\n              Establece el modo de teclado actual.  argp es un long int igual a uno de los valores de antes.\n\n       KDGKBMETA\n              Obtiene el modo de manejo de la tecla META. argp apunta a un long int que se pone con uno de estos\n              valores:\n\n                  K_METABIT     0x03   pone a 1 el bit de m\u00e1s alto orden\n                  K_ESCPREFIX   0x04   prefijo de ESCAPE\n\n       KDSKBMETA\n              Establece  el  modo  de  manejo  de la tecla META.  argp es un long int igual a uno de los valores\n              anteriores.\n\n       KDGKBENT\n              Obtiene una entrada de la tabla de traducci\u00f3n de teclas (c\u00f3digo de tecla a coigo de acci\u00f3n).  argp\n              apunta a una\n\n              struct kbentry {\n                  u_char kb_table;\n                  u_char kb_index;\n                  u_short kb_value;\n              };\n\n              con  los  primeros  dos  miembros  llenos: kb_table selecciona la tabla de teclas (0 <= kb_table <\n              MAX_NR_KEYMAPS), y kb_index es el c\u00f3digo de tecla (0 <= kb_index < NR_KEYS).  kb_value se pone  al\n              c\u00f3digo  de  acci\u00f3n  correspondiente,  o  K_HOLE  si no hay tal tecla, o K_NOSUCHMAP si kb_table es\n              inv\u00e1lido.\n\n       KDSKBENT\n              Establece una entrada en la tabla de traducci\u00f3n. argp apunta a una struct kbentry.\n\n       KDGKBSENT\n              Obtiene una cadena de tecla de funci\u00f3n. argp apunta a una\n\n              struct kbsentry {\n                  u_char kb_func;\n                  u_char kb_string[512];\n              };\n\n              kb_string es pone a la cadena (terminada en cero) correspondiente al c\u00f3digo de acci\u00f3n de la  tecla\n              de funci\u00f3n kb_func-sima.\n\n       KDSKBSENT\n              Establece una entrada de cadena de tecla de funci\u00f3n.  argp apunta a una struct kbsentry.\n\n       KDGKBDIACR\n              Lee la tabla de acentos del n\u00facleo. argp apunta a una\n\n              struct kbdiacrs {\n                  unsigned int kb_cnt;\n                  struct kbdiacr kbdiacr[256];\n              };\n\n              donde kb_cnt es el n\u00famero de entradas en el vector, cada una siendo una\n\n              struct kbdiacr { u_char diacr, base, result; };\n\n       KDGETKEYCODE\n              Lee una entrada de la tabla de c\u00f3digos de teclas del n\u00facleo (c\u00f3digo de rastreo a c\u00f3digo de tecla).\n              argp apunta a una\n\n              struct kbkeycode { unsigned int scancode, keycode; };\n\n              keycode se pone a un valor correspondiente al scancode dado.  (89 <= scancode  <=  255  solamente.\n              Para 1 <= scancode <= 88, keycode==scancode.)  (Desde 1.1.63.)\n\n       KDSETKEYCODE\n              Escribe una entrada de tabla de c\u00f3digos de teclas del n\u00facleo.  argp apunta a una struct kbkeycode.\n              (Desde 1.1.63.)\n\n       KDSIGACCEPT\n              El proceso que hace la llamada indica su voluntad de aceptar la se\u00f1al argp cuando se genere por la\n              pulsaci\u00f3n  de  una combinaci\u00f3n de teclas apropiada.  (1 <= argp <= NSIG).  (Vea spawn_console() en\n              linux/drivers/char/keyboard.c.)\n\n       VT_OPENQRY\n              Devuelve la primera consola disponible (no abierta).  argp apunta a un int que se pone  al  n\u00famero\n              de la vt (1 <= *argp <= MAX_NR_CONSOLES).\n\n       VT_GETMODE\n              Obtiene el modo de la vt activa.  argp apunta a una\n\n              struct vt_mode {\n                  char mode;     /* modo de la vt */\n                  char waitv;    /* si puesto, se cuelga en escrituras si no activa */\n                  short relsig;  /* se\u00f1al a lanzar en petici\u00f3n de liberaci\u00f3n */\n                  short acqsig;  /* se\u00f1al a lanzar en adquisici\u00f3n */\n                  short frsig;   /* sin uso (a 0) */\n              };\n\n              mode se pone a uno de estos valores:\n\n                  VT_AUTO       cambio de vt autom\u00e1tico\n                  VT_PROCESS    cambio de controles de proceso\n                  VT_ACKACQ     cambio de confirmaci\u00f3n\n\n       VT_SETMODE\n              Establece el modo de la vt activa.  argp apunta a una struct vt_mode.\n\n       VT_GETSTATE\n              Obtiene informaci\u00f3n de estado global de vt. argp apunta a una\n\n              struct vt_stat {\n                  ushort v_active;  /* vt activa */\n                  ushort v_signal;  /* se\u00f1al a enviar */\n                  ushort v_state;   /* m\u00e1scara de bits de la vt */\n              };\n\n              Para  cada  vt  en  uso, el bit correspondiente en el miembro v_state se pone a 1.  (N\u00facleos 1.0 a\n              1.1.92.)\n\n       VT_RELDISP\n              Libera una pantalla.\n\n       VT_ACTIVATE\n              Cambia a la vt argp (1 <= argp <= MAX_NR_CONSOLES).\n\n       VT_WAITACTIVE\n              Espera hasta que la vt argp ha sido activada.\n\n       VT_DISALLOCATE\n              Desaloja la memoria asociada con la vt argp.  (Desde 1.1.54.)\n\n       VT_RESIZE\n              Establece la idea que tiene el n\u00facleo del tama\u00f1o de pantalla. argp apunta a una\n\n              struct vt_sizes {\n                  ushort v_rows;       /* N\u00ba de filas */\n                  ushort v_cols;       /* N\u00ba de columnas */\n                  ushort v_scrollsize; /* ya no se usa */\n              };\n\n              Note que esto no cambia el modo de v\u00eddeo.  Vea resizecons(8).  (Desde 1.1.54.)\n\n       VT_RESIZEX\n              Establece la idea que tiene el n\u00facleo sobre varios par\u00e1metros de pantalla.  argp apunta a una\n\n              struct vt_consize {\n                      ushort v_rows;          /* n\u00famero de filas */\n                      ushort v_cols;          /* n\u00famero de columnas */\n                      ushort v_vlin;          /* N\u00ba de filas de p\u00edxeles en la pantalla */\n                      ushort v_clin;          /* N\u00ba de filas de p\u00edxeles por car\u00e1cter */\n                      ushort v_vcol;          /* N\u00ba de cols. de p\u00edxeles en la pantalla */\n                      ushort v_ccol;          /* N\u00ba de cols. de p\u00edxeles por car\u00e1cter */\n              };\n\n              Cualquier par\u00e1metro puede ponerse a cero, indicando ``no hay cambio'', pero  si  se  ponen  varios\n              par\u00e1metros,  deben  ser  auto-consistentes.  Note  que  esto  no  cambia  el  modo  de  v\u00eddeo. Vea\n              resizecons(8). (Desde 1.3.3.)\n\n       La acci\u00f3n de las siguientes ioctls depende del primer byte en la struct apuntada por argp, referido  aqu\u00ed\n       como el sub-c\u00f3digo. \u00c9stos son legales s\u00f3lo para el s\u00faper-usuario o el propietario de la tty actual.\n\n       TIOCLINUX, sub-c\u00f3digo=0\n              Vuelca  la  pantalla.  Desapareci\u00f3 en 1.1.92. (Con el n\u00facleo 1.1.92 o superior, lee de /dev/vcsN o\n              /dev/vcsaN en su lugar.)\n\n       TIOCLINUX, sub-c\u00f3digo=1\n              Obtiene informaci\u00f3n de tarea. Desapareci\u00f3 en 1.1.92.\n\n       TIOCLINUX, sub-c\u00f3digo=2\n              Establece selecci\u00f3n.  argp apunta a una\n\n                 struct {char subcode;\n                     short xs, ys, xe, ye;\n                     short sel_mode;\n                 }\n\n              xs e ys son las columna y fila de comienzo.  xe e ye son la columna y fila de final.  (La  esquina\n              superior  izquierda  es file=columna=1.)  sel_mode es 0 para selecci\u00f3n car\u00e1cter a car\u00e1cter, 1 para\n              selecci\u00f3n palabra a palabra, \u00f3 2 para  selecci\u00f3n  l\u00ednea  a  l\u00ednea.   Los  caracteres  de  pantalla\n              indicados se resaltan y salvan en el vector est\u00e1tico sel_buffer en devices/char/console.c.\n\n       TIOCLINUX, sub-c\u00f3digo=3\n              Selecci\u00f3n de pegado.  Los caracteres en el b\u00fafer de selecci\u00f3n se escriben a fd.\n\n       TIOCLINUX, sub-c\u00f3digo=4\n              Desblanquea la pantalla.\n\n       TIOCLINUX, sub-c\u00f3digo=5\n              Establece los contenidos de una tabla de b\u00fasqueda de 256 b que define caracteres en una \"palabra\",\n              para la selecci\u00f3n palabra a palabra. (Desde 1.1.32.)\n\n       TIOCLINUX, sub-c\u00f3digo=6\n              argp apunta a un  char que se pone con el valor de la variable  del  n\u00facleo  shift_state.   (Desde\n              1.1.32.)\n\n       TIOCLINUX, sub-c\u00f3digo=7\n              argp  apunta  a  un  char  que  se  pone  al valor de la variable del n\u00facleo report_mouse.  (Desde\n              1.1.33.)\n\n       TIOCLINUX, sub-c\u00f3digo=8\n              Vuelca la anchura y altura de la pantalla, posici\u00f3n  de  cursor,  y  todos  los   pares  car\u00e1cter-\n              atributo.   (N\u00facleos  1.1.67  a  1.1.91  solamente.   Con  el  n\u00facleo  1.1.92  \u00f3 posterior, lee de\n              /dev/vcsa* en su lugar.)\n\n       TIOCLINUX, sub-c\u00f3digo=9\n              Restaura la anchura y altura de la pantalla, posici\u00f3n de cursor,  y  todos  los   pares  car\u00e1cter-\n              atributo.   (N\u00facleos  1.1.67  a  1.1.91  solamente.   Con el n\u00facleo 1.1.92 \u00f3 posterior, escribe en\n              /dev/vcsa* en su lugar.)\n\n       TIOCLINUX, sub-c\u00f3digo=10\n              Maneja la caracter\u00edstica de Ahorro de Energ\u00eda de la nueva generaci\u00f3n de  monitores.   El  modo  de\n              blanqueo de pantalla VESA se pone a argp[1], que gobierna lo que hace el blanqueo de pantalla:\n\n                  0: El blanqueo de pantalla es deshabilitado.\n\n                  1: Se guardan los valores de los registros del adaptador de v\u00eddeo instalado, luego se programa\n              el controlador para apagar los pulsos de sincronizaci\u00f3n vertical.  Esto  pone  el  monitor  en  el\n              estado  de  \"modo de espera\". Si su monitor tiene un temporizador Off_Mode, entonces eventualmente\n              se apagar\u00e1 solo.\n\n                  2: Se salvan los valores actuales, luego se apagan los pulsos  de  sincronizaci\u00f3n  vertical  y\n              horizontal.   Esto  pone  el monitor en modo de \"apagado\".  Si su monitor no tiene el temporizador\n              Off_Mode, o si Ud. quiere que su monitor se apague inmediatamente cuando el tiempo del blank_timer\n              pase, entonces debe escoger esta opci\u00f3n.  (Precauci\u00f3n:: Apagar frecuentemente da\u00f1ar\u00e1 el monitor.)\n\n              (Desde 1.1.76.)\n\nVALOR DEVUELTO\n       En caso de \u00e9xito se devuelve 0. En caso de error se devuelve -1 y errno toma un valor.\n\n", "ERRORES": "       errno puede tomar uno de estos valores:\n\n       EBADF  el descriptor de fichero es inv\u00e1lido.\n\n       ENOTTY el descriptor de fichero no est\u00e1 asociado con un dispositivo especial de caracteres, o la petici\u00f3n\n              especificada no se aplica a \u00e9l.\n\n       EINVAL el descriptor de fichero o argp es inv\u00e1lido.\n\n       EPERM  violaci\u00f3n de permiso.\n\n", "ATENCI\u00d3N": "       No mire esta p\u00e1gina del Manual como documentaci\u00f3n sobre las ioctl's de la consola de Linux.  Esta  p\u00e1gina\n       s\u00f3lo  se  proporciona  para  el  curioso,  como una alternativa a leer los fuentes. Las ioctl's son cosas\n       internas de Linux indocumentadas, sujetas a cambios  sin  previo  aviso.  (Y  desde  luego,  esta  p\u00e1gina\n       describe  m\u00e1s  o  menos  la  situaci\u00f3n  en  los tiempos del n\u00facleo versi\u00f3n 1.1.94; hay muchas diferencias\n       menores y no tan menores con versiones anteriores.)\n\n       Muy a menudo, las ioctl's se introducen para comunicaci\u00f3n entre el n\u00facleo y un programa  particular  bien\n       conocido  (fdisk,  hdparm,  setserial,  tunelp,  loadkeys, selection, setfont, etc.), y su comportamiento\n       cambiar\u00e1 cuando se requiera por este programa particular.\n\n       Los programas que usen estas ioctl's no ser\u00e1n transportables a otras versiones de Unix, no funcionar\u00e1n en\n       versiones m\u00e1s antiguas de Linux, y no funcionar\u00e1n en versiones futuras de Linux.\n\n       Use funciones POSIX.\n\nV\u00c9ASE TAMBI\u00c9N\n       kbd_mode(1),  loadkeys(1),  dumpkeys(1),  mknod(1),  setleds(1),  setmetamode(1),  ioperm(2),  execve(2),\n       fcntl(2), termios(3), console(4), console_codes(4), mt(4), sd(4), tty(4), ttys(4), tty_ioctl(4),  vcs(4),\n       vcsa(4),     charsets(7),     mapscrn(8),     setfont(8),     resizecons(8),     /usr/include/linux/kd.h,\n       /usr/include/linux/vt.h\n\nLinux                                          18 septiembre 1995                              CONSOLE_IOCTLS(4)\n"},{"NOMBRE": "       dsp56k - interfaz con el dispositivo DSP56001\n\n", "SINOPSIS": "       #include <asm/dsp56k.h>\n\n       ssize_t read(int fd, void *data, size_t length);\n       ssize_t write(int fd, void *data, size_t length);\n       int ioctl(int fd, DSP56K_UPLOAD, struct dsp56k_upload *program);\n       int ioctl(int fd, DSP56K_SET_TX_WSIZE, int wsize);\n       int ioctl(int fd, DSP56K_SET_RX_WSIZE, int wsize);\n       int ioctl(int fd, DSP56K_HOST_FLAGS, struct dsp56k_host_flags *flags);\n       int ioctl(int fd, DSP56K_HOST_CMD, int cmd);\n\n", "CONFIGURACI\u00d3N": "       El dispositivo dsp56k es un dispositivo de caracteres con n\u00famero mayor 55 y n\u00famero menor 0.\n\n", "DESCRIPCI\u00d3N": "       El  Motorola  DSP56001  es  un  procesador  de se\u00f1ales digitales de 24 bits totalmente programable que se\n       encuentra en computadores compatibles con Atari Falcon030.  El fichero especial dsp56k  se  utiliza  para\n       controlar  el  DSP56001, y para enviar y recibir datos usando el puerto de host bidireccional mediante la\n       t\u00e9cnica de handshaking.\n\n       Para enviar un flujo de datos al procesador de se\u00f1ales, utilice write() con el dispositivo, y read() para\n       recibir datos procesados. Los datos pueden ser enviados o recibidos en cantidades de 8, 16, 24, o 32 bits\n       por parte del host, pero siempre ser\u00e1n interpretados como cantidades de 24 bits por el DSP56001.\n\n       Las siguientes llamadas ioctl(2) pueden utilizarse para controlar el dispositivo dsp56k:\n\n       DSP56K_UPLOAD\n              reinicia el DSP56001 y carga un programa. El tercer argumento a ioctl() debe ser un puntero a  una\n              estructura  dsp56k_binary  donde  el  miembro  bin  apuntar\u00e1 a un programa binario DSP56001, y len\n              contendr\u00e1 la longitud del programa en palabras de 24 bits.\n\n       DSP56K_SET_TX_WSIZE\n              establece el tama\u00f1o de la palabra de transmisi\u00f3n. Los valores permitidos est\u00e1n en el intervalo  de\n              1  a  4,  y  definen  el  n\u00famero  de  bytes  que ser\u00e1n enviados al mismo tiempo al DSP56001. Estas\n              cantidades de datos ser\u00e1n o bien rellenadas con bytes cero, o truncadas para  que  se  ajusten  al\n              formato nativo de 24 bits del DSP56001.\n\n       DSP56K_SET_RX_WSIZE\n              establece  el tama\u00f1o de la palabra de recepci\u00f3n. Los valores permitidos est\u00e1n en el intervalo de 1\n              a 4, y definen el n\u00famero de bytes  que  ser\u00e1n  recibidos  al  mismo  tiempo  del  DSP56001.  Estas\n              cantidades  de  datos  ser\u00e1n  o bien rellenadas con bytes cero, o truncadas para que se ajusten al\n              formato nativo de 24 bits del DSP56001.\n\n       DSP56K_HOST_FLAGS\n              lee y escribe las banderas (flags) del host. Las banderas del host son cuatro  bits  de  prop\u00f3sito\n              general que pueden ser le\u00eddos tanto por la m\u00e1quina anfitriona como por el DSP56001. Los bits 0 y 1\n              pueden ser escritos por el host, y los bits 2 y 3 pueden ser escritos por el DSP56001.\n\n              Para acceder a estas banderas del host, el tercer argumento a ioctl() debe ser un  puntero  a  una\n              estructura  dsp56k_host_flags.  Si  el  bit  0  o el bit 1 est\u00e1n activos en el miembro dir, el bit\n              correspondiente en out ser\u00e1 escrito en las banderas del host. El estado de todas las banderas ser\u00e1\n              devuelto en los cuatro bits de orden inferior del miembro status.\n\n       DSP56K_HOST_CMD\n              env\u00eda  una  orden  de  anfitri\u00f3n.  Los  valores  permitidos  est\u00e1n  en  el  intervalo de 0 a 31, y\n              especifican una orden definida por el usuario que es manejado por el programa que se ejecuta en el\n              DSP56001.\n\n", "FICHEROS": "       /dev/dsp56k\n\n", "AUTORES": "       Fredrik    Noring    <noring@nocrew.org>,    lars    brinkhoff    <lars@nocrew.org>,   Tomas   Berndtsson\n       <tomas@nocrew.org>.\n\nV\u00c9ASE TAMBI\u00c9N\n       linux/include/asm-m68k/dsp56k.h,         linux/drivers/char/dsp56k.c,          http://dsp56k.nocrew.org/,\n       DSP56000/DSP56001 Digital Signal Processor User's Manual\n\nLinux                                             1 marzo 2000                                         DSP56K(4)\n"},{"NOMBRE": "       fd - dispositivo de disco flexible (disquetera)\n\n", "CONFIGURACI\u00d3N": "       Las unidades de disco flexible son dispositivos hardware cuyo n\u00famero mayor es 2. Tipicalmente, pertenecen\n       a root.floppy (es decir, usuario root, grupo floppy) y tienen o bien el modo  0660  (la  comprobaci\u00f3n  de\n       acceso se realiza a trav\u00e9s de la pertenencia al grupo) o bien el modo 0666 (cualquiera tiene acceso). Los\n       n\u00fameros menorer codifican el tipo de dispositivo, n\u00famero de dispositivo, n\u00famero de controlador. Para cada\n       tipo  de  dispositivo (es decir, combinaci\u00f3n de densidad y n\u00famero de pistas) hay un numero base menor.  A\n       este n\u00famero base, suma el n\u00famero de dispositivo en su controladora y 128 si el  dispositivo  est\u00e1  en  el\n       controlador  secundario.   En  las  siguientes  tablas  de  dispositivos,  n  representan  el  n\u00famero  de\n       dispositivo.\n\n       Cuidado: Si usas formatos con m\u00e1s pistas que las soportadas por tu  dispositivo,  puedes  causarle  da\u00f1os\n       mec\u00e1nicos.   Probar una vez si se soportan m\u00e1s pistas de las usuales 40/80 no deber\u00eda da\u00f1arlo, pero no se\n       da ninguna garant\u00eda por ello.  No crees entradas de dispositivos para esos formatos para prevenir su  uso\n       si no estas seguro.\n\n       Ficheros independientes del dispositivo que detectan autom\u00e1ticamente el formato y la capacidad del medio:\n\n       Nombre   N\u00ba base menor\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       fdn 0\n\n       Ficheros de dispositivos de doble densidad y 5.25\":\n\n       Nombre       Capac.   Cil.   Sect.   Cabez.   N\\[u00BA] base menor\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       fdnd360      360K     40     9       2        4\n\n       Ficheros de dispositivos de alta densidad y 5.25\":\n\n       Nombre       Capac.   Cil.   Sect.   Cabez.   N\u00ba base menor\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       fdnh360      360K     40     9       2        20\n       fdnh410      410K     41     10      2        48\n       fdnh420      420K     42     10      2        64\n       fdnh720      720K     80     9       2        24\n       fdnh880      880K     80     11      2        80\n       fdnh1200     1200K    80     15      2        8\n       fdnh1440     1440K    80     18      2        40\n       fdnh1476     1476K    82     18      2        56\n       fdnh1494     1494K    83     18      2        72\n       fdnh1600     1600K    80     20      2        92\n\n       Ficheros de dispositivos de doble densidad y 3.5\":\n\n       Nombre       Capac.   Cil.   Sect.   Cabez.   N\u00ba base menor\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       fdnD360      360K     80     9       1        12\n       fdnD720      720K     80     9       2        16\n       fdnD800      800K     80     10      2        120\n       fdnD1040     1040K    80     13      2        84\n       fdnD1120     1120K    80     14      2        88\n\n       Ficheros de de dispositivos de alta densidad y 3.5\":\n\n       Nombre       Capac.   Cil.   Sect.   Cabez.   N\u00ba base menor\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n       fdnH360      360K     40     9       2        12\n       fdnH720      720K     80     9       2        16\n       fdnH820      820K     82     10      2        52\n       fdnH830      830K     83     10      2        68\n       fdnH1440     1440K    80     18      2        28\n       fdnH1600     1600K    80     20      2        124\n       fdnH1680     1680K    80     21      2        44\n       fdnH1722     1722K    82     21      2        60\n       fdnH1743     1743K    83     21      2        76\n       fdnH1760     1760K    80     22      2        96\n       fdnH1840     1840K    80     23      2        116\n       fdnH1920     1920K    80     24      2        100\n\n       Ficheros de dispositivos de densidad extra y 3.5\":\n\n       Nombre       Capac.   Cil.   Sect.   Cabez.   N\u00ba base menor\n       \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n       fdnE2880     2880K    80     36      2        32\n       fdnCompaQ    2880K    80     36      2        36\n       fdnE3200     3200K    80     40      2        104\n       fdnE3520     3520K    80     44      2        108\n       fdnE3840     3840K    80     48      2        112\n\n", "DESCRIPCI\u00d3N": "       Los  ficheros  especiales  fd  acceden a las unidades de disquete en modo crudo.  Las siguientes llamadas\n       ioctl(2) est\u00e1n soportadas por dispositivos fd:\n\n       FDCLRPRM\n              borra la informaci\u00f3n del medio de una unidad (geometr\u00eda del disco en la unidad).\n\n       FDSETPRM\n              Establece la informaci\u00f3n del medio de una unidad. La informaci\u00f3n del medio se  perder\u00e1  cuando  se\n              cambie de medio.\n\n       FDDEFPRM\n              Establece  la  informaci\u00f3n  del  medio  de  una  unidad  (geometr\u00eda  del  disco  en la unidad). La\n              informaci\u00f3n del medio no se perder\u00e1 cuando se cambie de medio.  Esto desactivar\u00e1 la autodetecci\u00f3n.\n              En orden a reactivar la autodetecci\u00f3n, tienes que emitir un FDCLRPRM .\n\n       FDGETDRVTYP\n              devuelve el tipo de una unidad (parametro nombre).  Para formatos que funcionan en varios tipos de\n              unidad, FDGETDRVTYP devuelve un nombre el cu\u00e1l es apropiado para el tipo de unidad m\u00e1s antiguo que\n              soporta este formato.\n\n       FDFLUSH\n              invalida el cache de buffer para la unidad dada.\n\n       FDSETMAXERRS\n              ajusta  el umbral de error para informar de errores, abortar la operaci\u00f3n, recalibrar, reinicar la\n              unidad y leer sector a sector.\n\n       FDSETMAXERRS\n              obtiene el umbral actual de error.\n\n       FDGETDRVTYP\n              obtiene el nombre interno de la unidad.\n\n       FDWERRORCLR\n              borra la estad\u00edstica de errores de escritura.\n\n       FDWERRORGET\n              lee la estad\u00edstica de errores de escritura. Esto incluye el n\u00famero total de errores de  escritura,\n              la  posici\u00f3n  y  disco  del  primer  error de escritura, y la posici\u00f3n y disco del \u00faltimo error de\n              escritura. Los discos se identifican mediante un n\u00famero de generaci\u00f3n el cu\u00e1l  se  incrementa  (al\n              menos) en cada cambio de disco.\n\n       FDTWADDLE\n              Apaga el motor de la unidad por unos pocos microsegundos. Esto podr\u00eda ser necesario para acceder a\n              un disco cuyos sectores est\u00e1n muy juntos.\n\n       FDSETDRVPRM\n              ajusta varios parametros de unidad.\n\n       FDGETDRVPRM\n              devuelve los par\u00e1metros anteriores.\n\n       FDGETDRVSTAT\n              obtiene el estado de la cache de la unidad (cambios de disco, protecci\u00f3n de escritura)\n\n       FDPOLLDRVSTAT\n              consulta a la unidad y devuelve su estado.\n\n       FDGETFDCSTAT\n              obtiene el estado del controlador de la disquetera.\n\n       FDRESET\n              reinicia el controlador de la disquetera bajo ciertas condiciones.\n\n       FDRAWCMD\n              env\u00eda una orden directa al controlador de la disquetera.\n\n       Para  una  informaci\u00f3n  m\u00e1s  precisa,  consultar  tambi\u00e9n  los  ficheros  de  cabecera   <linux/fd.h>   y\n       <linux/fdreg.h>, as\u00ed como la p\u00e1gina de manual para floppycontrol.\n\n", "OBSERVACIONES": "       Los  diversos formatos permiten leer y escribir muchos tipos de discos.  No obstante, si un disquete est\u00e1\n       formateado con un espacio entre sectores demasiado peque\u00f1o, el rendimiento puede caer, hasta el punto  de\n       necesitar  unos  pocos  segundos  para  acceder a una pista entera. Para prevenir esto, usar formatos con\n       entrelazado. No es posible leer discos que han sido formateados usando GCR(group code recording), la cu\u00e1l\n       se  usa  en computadores Apple II y Macintosh (discos de 800K). No est\u00e1 soportada la lectura de disquetes\n       con los sectores marcados f\u00edsicamente, mediante un agujero por sector.   Esto  sol\u00eda  ser  com\u00fan  en  los\n       viejos disquetes de 8 pulgadas.\n\n", "FICHEROS": "       /dev/fd*\n\n", "AUTORES": "       Alain Knaff (Alain.Knaff@imag.fr), David Niemi (niemidc@clark.net), Bill Broadhurst (bbroad@netcom.com).\n\nV\u00c9ASE TAMBI\u00c9N\n       floppycontrol(1), mknod(1), chown(1), getfdprm(1), superformat(1), mount(8), setfdprm(8)\n\nLinux                                             29 Enero 1995                                            FD(4)\n"},{"NOMBRE": "       fifo - fichero especial \"primero en entrar, primero en salir\", tuber\u00eda con nombre\n\n", "DESCRIPCI\u00d3N": "       Un fichero especial FIFO (una tuber\u00eda con nombre) es similar a una tuber\u00eda, salvo que se accede a \u00e9l como\n       parte del sistema de ficheros. Puede ser abierto por m\u00faltiples procesos para lectura o escritura.  Cuando\n       los  procesos  intercambian  datos  a  trav\u00e9s de la FIFO, el n\u00facleo pasa todos los datos internamente sin\n       escribirlos en el sistema de ficheros. Por tanto, el fichero especial  FIFO  no  tiene  contenido  en  el\n       sistema  de ficheros, la entrada del sistema de ficheros simplemente sirve como un punto de referencia de\n       tal manera que los procesos puedan acceder a la tuber\u00eda usando un nombre del sistema de ficheros.\n\n       El n\u00facleo mantiene exactamente un \u00fanico objeto tuber\u00eda para cada fichero especial  FIFO  que  es  abierto\n       por,  al menos, un proceso. Se debe abrir la FIFO en ambos extremos (de lectura y escritura) antes de que\n       se puedan pasar datos. Normalmente, la apertura de la FIFO se bloquea hasta que el otro  extremo  tambi\u00e9n\n       se abre.\n\n       Un proceso puede abrir una FIFO en modo no bloqueante. En este caso, abrir para s\u00f3lo lectura tendr\u00e1 \u00e9xito\n       incluso si nadie ha abierto todav\u00eda el lado de escritura. Abrir para s\u00f3lo escritura fallar\u00e1 con una ENXIO\n       (no existe tal dispositivo o direcci\u00f3n) a menos que el otro extremo ya se haya abierto.\n\n       En  Linux,  abrir  una  FIFO  para  lectura  y  escritura  tendr\u00e1  \u00e9xito tanto en modo bloqueante como no\n       bloqueante. POSIX deja sin definir este comportamiento.  Esto se puede usar  para  abrir  una  FIFO  para\n       escribir  mientras  no  hay  lectores  disponibles. Un proceso que usa ambos extremos de la conexi\u00f3n para\n       comunicarse consigo mismo deber\u00eda tener cuiado para evitar bloqueos mortales.\n\n", "OBSERVACIONES": "       Cuando un proceso intenta escribir en una FIFO que no est\u00e1 abierta para lectura en el otro  lado,  se  le\n       env\u00eda una se\u00f1al SIGPIPE.\n\n       Los ficheros especiales FIFO se pueden crear con mkfifo(3) y se indican de manera especial en ls -l.\n\nV\u00c9ASE TAMBI\u00c9N\n       mkfifo(3), mkfifo(1), pipe(2), socketpair(2), open(2), signal(2), sigaction(2)\n\nP\u00e1gina Man de Linux                               20 junio 1999                                          FIFO(4)\n"},{"NOMBRE": "       full - dispositivo siempre lleno\n\n", "DESCRIPCI\u00d3N": "       El  fichero  /dev/full tiene como n\u00famero mayor de dispositivo el 1, y como n\u00famero menor de dispositivo el\n       7.\n\n       Las escrituras en el dispositivo /dev/full fallar\u00e1n con un error ENOSPC.\n\n       Las lecturas desde el dispositivo /dev/full devolver\u00e1n caracteres nulos (\\0).\n\n       Las b\u00fasquedas en /dev/full siempre tendr\u00e1n \u00e9xito.\n\n", "CONFIGURACI\u00d3N": "       Si su sistema no tiene creado a\u00fan el dispositivo. /dev/full , \u00e9ste se  puede  crear  con  las  siguientes\n       \u00f3rdenes:\n               mknod -m 666 /dev/full c 1 7\n               chown root:root /dev/full\n\n", "FICHEROS": "       /dev/full\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), null(4), zero(4)\n\nLinux                                             2 Agosto 1997                                          FULL(4)\n"},{"NOMBRE": "       futex - llamada al sistema para bloqueos r\u00e1pidos en espacio de usuario\n\n", "SINOPSIS": "       #include <linux/futex.h>\n\n       #include <sys/time.h>\n\n       int sys_futex (void *futex, int op, int val, const struct timespec *timeout);\n\n", "DESCRIPCI\u00d3N": "       La  llamada al sistema sys_futex proporciona un m\u00e9todo que permite a un programa esperar hasta que cambie\n       el valor de una direcci\u00f3n dada y un m\u00e9todo para despertar a cualquier proceso que est\u00e9 esperando  en  una\n       direcci\u00f3n  particular (aunque las direcciones para una misma zona de memoria en procesos separados pueden\n       no ser iguales, el n\u00facleo las proyecta internamente para que la misma memoria proyectada  en  direcciones\n       distintas  concuerde  para diferentes llamadas sys_futex). T\u00edpicamente se usa para implementar el caso de\n       contienda de un bloqueo en memoria compartida, como se describe en futex(4).\n\n       Cuando una operaci\u00f3n futex(4) termina con contienda en espacio de usuario, es necesario hacer una llamada\n       al  n\u00facleo  para  que  arbitre.  El  arbitraje  puede  significar  o  bloquear  al  proceso  invocador o,\n       contrariamente, despertar a un proceso bloqueado.\n\n       Se espera que los procesos que llamen a esta funci\u00f3n  se  adhieran  a  la  sem\u00e1ntica  que  se  expone  en\n       futex(4).  Ya que esta sem\u00e1ntica supone escribir instrucciones en ensamblador no (trans)portables, esto a\n       su vez probablemente significa que la mayor\u00eda de los usuarios ser\u00e1n de hecho autores de bibliotecas y  no\n       desarrolladores gen\u00e9ricos de aplicaciones.\n\n       Es  necesario que el argumento futex apunte a un entero alineado que almacene el contador. La operaci\u00f3n a\n       ejecutar se pasa a trav\u00e9s del par\u00e1metro op junto con un valor val.\n\n       Actualmente se definen tres operaciones:\n\n       FUTEX_WAIT\n              Esta operaci\u00f3n verifica at\u00f3micamente si la direcci\u00f3n  futex  contiene  todav\u00eda  el  valor  dado  y\n              bloquea  al  proceso a la espera de FUTEX_WAKE en esta direcci\u00f3n futex. Si el argumento timeout no\n              es NULL, su contenido describe la duraci\u00f3n m\u00e1xima de la espera, que es infinita en otro caso. Para\n              futex(4),  esta  llamada  se  ejecuta  si  al  decrementar el contador se obtuvo un valor negativo\n              (indicando contenci\u00f3n) y se bloquear\u00e1 hasta  que  otro  proceso  libere  el  futex  y  ejecute  la\n              operaci\u00f3n FUTEX_WAKE.\n\n       FUTEX_WAKE\n              Esta  operaci\u00f3n despierta, como mucho, val procesos que esperan en esta direcci\u00f3n futex (es decir,\n              dentro de FUTEX_WAIT).  Para futex(4), esta llamada se ejecuta si al incrementar  el  contador  se\n              vio  que hab\u00eda procesos esperando una vez que al futex se le ha asignado el valor 1 (indicando que\n              est\u00e1 disponible).\n\n       FUTEX_FD\n              Para soportar despertares as\u00edncronos, esta operaci\u00f3n asocia un descriptor de fichero con un futex.\n              Si  otro proceso ejecuta un FUTEX_WAKE, el proceso recibir\u00e1 el n\u00famero de se\u00f1al que se pas\u00f3 en val.\n              El proceso invocador debe cerrar el descriptor de fichero devuelto despu\u00e9s de su uso.\n\n              Para evitar condiciones de carrera, el invocador debe comprobar si se  ha  incrementado  el  futex\n              despu\u00e9s de que FUTEX_FD regrese.\n\nVALOR DEVUELTO\n       Dependiendo de la operaci\u00f3n que se haya ejecutado, el valor devuelto puede tener significados diferentes.\n\n       FUTEX_WAIT\n              Devuelve  0  si  el  proceso  fue  despertado  por  una llamada FUTEX_WAKE. En el caso de que haya\n              expirado el plazo, se devuelve ETIMEDOUT. Si el futex no era igual al valor esperado, la operaci\u00f3n\n              devuelve  EWOULDBLOCK.  Las  se\u00f1ales  (u  otros  falsos despertares) hacen que FUTEX_WAIT devuelva\n              EINTR.\n\n       FUTEX_WAKE\n              Devuelve el n\u00famero de procesos despertados.\n\n       FUTEX_FD\n              Devuelve el nuevo descriptor de fichero asociado al futex.\n\n", "OBSERVACIONES": "       Insistimos, los futexes, en su forma m\u00e1s b\u00e1sica, no est\u00e1n pensados como  abstracci\u00f3n  sencilla  para  los\n       usuarios  finales.  Es  de  esperar  que los implementadores sean buenos conocedores de ensamblador y que\n       hayan le\u00eddo los fuentes de la biblioteca de futex en espacio de usuario que se indica m\u00e1s abajo.\n\n", "AUTORES": "       Los futexes fueron dise\u00f1ados e implementados por Hubertus Franke (IBM Thomas J. Watson Research  Center),\n       Matthew  Kirkwood,  Ingo  Molnar (Red Hat) y Rusty Russell (IBM Linux Technology Center). Esta p\u00e1gina fue\n       escrita por Bert Hubert.\n\n", "VERSIONES": "       El soporte inicial para futex se a\u00f1adi\u00f3 a la versi\u00f3n 2.5.7 de Linux pero con una sem\u00e1ntica distinta a  la\n       descrita m\u00e1s arriba. La sem\u00e1ntica actual se encuentra disponible desde la versi\u00f3n 2.5.40 de Linux.\n\nV\u00c9ASE TAMBI\u00c9N\n       futex(4), `Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux' (actas del Ottawa Linux Symposium\n       2002),         biblioteca         de         ejemplo          de          futex,          futex-*.tar.bz2\n       <URL:ftp://ftp.nl.kernel.org:/pub/linux/kernel/people/rusty/>.\n\n                                                31 diciembre 2002                                       FUTEX(2)\n"},{"NOMBRE": "       hd - dispositivo de disco duro MFM/IDE\n\n", "DESCRIPCI\u00d3N": "       hd*  son  los  dispositivos  de  bloque usados para acceder a los discos duros MFM/IDE en modo crudo (raw\n       mode).  El disco duro maestro de la controladora primaria IDE (dispositivo mayor n\u00famero  3)  es  hda.  el\n       disco  esclavo es hdb.  El dico maestro en la segunda controladora (dispositivo mayor n\u00famero 22) es hdc y\n       el esclavo hdd.\n\n       Los nombres de los dispositivos generales de bloque IDE son de la forma: hdX, o  hdXP,  donde  X  es  una\n       letra  que  denota  la  unidad  f\u00edsica, y P es un n\u00famero que indica la partici\u00f3n en la unidad f\u00edsica.  La\n       primera forma aqu\u00ed mostrada, hdX, es usada para  direccionar  la  unidad  entera.   Los  n\u00fameros  de  las\n       particiones  son  asignados  en  el  orden  que  se  descubran  las particiones, solo obtienen n\u00famero las\n       particiones no vac\u00edas y no extendidas. As\u00ed mismo, los  n\u00fameros  del  1  al  4  se  toman  de  las  cuatro\n       particiones  descritas  en el Master Boot Record (las particiones llamadas primarias), independientemente\n       de que no se usen o sean extendidas.  Asi, la primera partici\u00f3n l\u00f3gica ser\u00e1 hdX5.\n\n       Est\u00e1n soportadas las particiones tipo DOS y BSD.  Puede tener hasta 63 particiones en un disco IDE.\n\n       Por ejemplo, /dev/hda se refiere a la la primera unidad IDE completa; y /dev/hdb3 se refiere a la tercera\n       particion primaria DOS en la segunda unidad.\n\n       T\u00edpicamente se crean con:\n\n              mknod -m 660 /dev/hda b 3 0\n              mknod -m 660 /dev/hda1 b 3 1\n              mknod -m 660 /dev/hda2 b 3 2\n              ...\n              mknod -m 660 /dev/hda8 b 3 8\n              mknod -m 660 /dev/hdb b 3 64\n              mknod -m 660 /dev/hdb1 b 3 65\n              mknod -m 660 /dev/hdb2 b 3 66\n              ...\n              mknod -m 660 /dev/hdb8 b 3 72\n              chown root:disk /dev/hd*\n\n", "FICHEROS": "       /dev/hd*\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1), mount(8)\n\nLinux                                             30 Junio 1996                                            HD(4)\n"},{"NOMBRE": "       initrd - disco-RAM inicializado por el gestor de arranque\n\n", "DESCRIPCI\u00d3N": "       El fichero especial /dev/initrd es un dispositivo de bloques de s\u00f3lo lectura.  El dispositivo /dev/initrd\n       es un disco RAM que es inicializado (es decir, cargado) por el gestor  de  arranque  antes  de  cargar  e\n       iniciar  el  n\u00facleo  del sistema.  As\u00ed, el n\u00facleo puede utilizar el contenido del dispositivo /dev/initrd\n       para un arranque del sistema en dos fases.\n\n       En la primera fase del arranque, el n\u00facleo pone en marcha y monta un sistema de ficheros ra\u00edz  inicial  a\n       partir  del contenido de /dev/initrd (o sea, el disco-RAM inicializado por el gestor de arranque).  En la\n       segunda fase, se cargan controladores adicionales u otros m\u00f3dulos desde el contenido del dispositivo ra\u00edz\n       inicial.   Tras  cargar los m\u00f3dulos adicionales, se monta un nuevo sistema de ficheros ra\u00edz (es decir, el\n       sistema de ficheros ra\u00edz habitual) desde un dispositivo diferente.\n\nFUNCIONAMIENTO DEL ARRANQUE\n       Cuando se arranca el sistema con initrd, ocurre lo siguiente:\n\n         1. El gestor de arranque ('boot loader') carga el n\u00facleo y el contenido de /dev/initrd en memoria.\n\n         2. En la puesta en marcha del n\u00facleo, \u00e9ste descomprime y copia el contenido del disp.   /dev/initrd  en\n         el dispositivo /dev/ram0 y a continuaci\u00f3n libera la memoria utilizada por /dev/initrd.\n\n         3.  Seguidamente, el n\u00facleo monta el dispositivo /dev/ram0 en modo lectura/escritura como el sistema de\n         ficheros ra\u00edz inicial.\n\n         4. Si el sistema de ficheros ra\u00edz habitual indicado coincide con el sistema de  ficheros  ra\u00edz  inicial\n         (por  ejemplo,  /dev/ram0  )  entonces el n\u00facleo salta directamente al \u00faltimo paso para la secuencia de\n         arranque habitual.\n\n         5. Si el fichero ejecutable /linuxrc est\u00e1 presente en el sistema de ficheros ra\u00edz inicial,  se  ejecuta\n         con  uid  (identificador  de  usuario)  0.   (El  fichero /linuxrc debe tener permiso de ejecuci\u00f3n.  El\n         fichero /linuxrc puede ser cualquier ejecutable v\u00e1lido, incluyendo los guiones de cualquier  procesador\n         de \u00f3rdenes -'shell scripts'.)\n\n         6.  Si no se ejecuta /linuxrc o cuando /linuxrc termina, se monta el sistema de ficheros ra\u00edz habitual.\n         (Si /linuxrc  termina  con  alg\u00fan  sistema  de  ficheros  montado  en  el  ra\u00edz  inicial,  entonces  el\n         comportamiento  del  n\u00facleo  es  INDETERMINADO.   (Vea  la  secci\u00f3n  OBSERVACIONES  para  consultar  el\n         comportamiento actual del n\u00facleo.)\n\n         7. Si el sistema de ficheros 'habitual' contiene el directorio /initrd,  el  dispositivo  /dev/ram0  se\n         mueve desde / a /initrd.  En otro caso, si el directorio /initrd no existe, el dispositivo /dev/ram0 se\n         desmonta.  (Cuando es movido desde / a /initrd, /dev/ram0 no se desmonta,  y  por  tanto  los  procesos\n         pueden  permanecer  funcionando  desde  /dev/ram0.  Si el directorio /initrd no existe en el sistema de\n         ficheros ra\u00edz habitual y queda alg\u00fan proceso en funcionamiento sobre /dev/ram0 cuando /linuxrc termina,\n         el  comportamiento  del  n\u00facleo  es  INDETERMINADO.   Vea la secci\u00f3n de OBSERVACIONES para consultar el\n         comportamiento actual del n\u00facleo.)\n\n         8. La secuencia de arranque/inicio habitual (por ejemplo, la ejecuci\u00f3n de /sbin/init) se realiza en  el\n         sistema de ficheros habitual.\n\n", "OPCIONES": "       Las  siguientes  opciones  del  gestor  de arranque, cuando se utilizan con initrd, alteran el proceso de\n       puesta en marcha del n\u00facleo:\n\n       initrd=nombre_de_fichero\n              Especifica el fichero a cargar como el contenido de /dev/initrd.  Para LOADLIN esta es una  opci\u00f3n\n              de  l\u00ednea  de  \u00f3rdenes.  Para LILO tiene que utilizar este orden en el fichero de configuraci\u00f3n de\n              LILO, /etc/lilo.config.  El nombre de fichero indicado con esta opci\u00f3n ser\u00e1 normalmente una imagen\n              del sistema de ficheros comprimida con GZip.\n\n       noinitrd\n              Esta  opci\u00f3n  de arranque deshabilita la operaci\u00f3n de arranque en dos fases.  El n\u00facleo realiza la\n              secuencia de arranque habitual como si /dev/initrd no hubiera sido inicializado.  Con esta opci\u00f3n,\n              cualquier contenido de /dev/initrd cargado en la memoria por el 'boot loader' es preservado.  Esta\n              opci\u00f3n permite que /dev/initrd contenga cualquier clase de datos y no est\u00e9 limitado a  una  imagen\n              de  sist. de ficheros.  De todas formas, el dispositivo /dev/initrd es de s\u00f3lo-lectura y puede ser\n              le\u00eddo s\u00f3lo una vez tras la puesta en marcha del sistema.\n\n       root=nombre-de-dispositivo\n              Especifica el dispositivo que ser\u00e1 utilizado como sistema de ficheros normal (ra\u00edz).  Para LOADLIN\n              esta  es una opci\u00f3n de l\u00ednea de \u00f3rdenes.  Para LILO esta es una opci\u00f3n para el momento de arranque\n              o puede utilizarse como l\u00ednea de opci\u00f3n en el fichero de configuraci\u00f3n de LILO,  /etc/lilo.config.\n              El dispositivo indicado por la opci\u00f3n debe ser un dispositivo 'montable', y contener un sistema de\n              ficheros ra\u00edz adecuado.\n\nCAMBIAR EL SISTEMA DE FICHEROS RA\u00cdZ HABITUAL\n       Por defecto, las opciones establecidas del n\u00facleo (p. ej. establecidas en el fichero del n\u00facleo  mediante\n       rdev  o  compiladas dentro del mismo), o el establecimiento de opciones del 'boot loader' se utiliza para\n       los sistemas de ficheros normales.  Para un sistema de fich. ra\u00edz montado como NFS, debemos utilizar  las\n       opciones  de  arranque  nfs_root_name  y nfs_root_addrs para proporcionar/establecer las opciones de NFS.\n       Para m\u00e1s informaci\u00f3n sobre sistemas ra\u00edz montados como NFS, vea el fichero de  documentaci\u00f3n  del  n\u00facleo\n       nfsroot.txt.   Para m\u00e1s informaci\u00f3n sobre el establecimiento del sistema de ficheros ra\u00edz, vea tambi\u00e9n la\n       doc. de LILO y LOADLIN.\n\n       Tambi\u00e9n es posible para el ejecutable de /linuxrc cambiar el dispositivo  ra\u00edz  por  defecto.   Para  que\n       /linuxrc  cambie  este  dispositivo, /proc debe ser montado.  Tras montar /proc, /linuxrc cambia el disp.\n       ra\u00edz habitual escribiendo en los ficheros /proc/sys/kernel/real-root-dev, /proc/sys/kernel/nfs-root-name,\n       y /proc/sys/kernel/nfs-root-addrs.  Para un dispositivo ra\u00edz f\u00edsico, \u00e9ste se cambia haciendo que /linuxrc\n       escriba el nuevo n\u00famero de sistema de ficheros en /proc/sys/kernel/real-root-dev.  Para un  sistema  ra\u00edz\n       NFS,  el  disp.  ra\u00edz  se  cambia  haciendo  que  /linuxrc  escriba  la  opci\u00f3n  de  NFS  en los ficheros\n       /proc/sys/kernel/nfs-root-name y /proc/sys/kernel/nfs-root-addrs y despu\u00e9s escriba 0xff (p.ej. el  n\u00famero\n       de pseudo-dispositivo-NFS) en el fichero /proc/sys/kernel/real-root-dev.  Por ejemplo, la siguiente l\u00ednea\n       de \u00f3rdenes del shell cambiar\u00eda el disp. ra\u00edz a /dev/hdb1:\n               echo 0x365 >/proc/sys/kernel/real-root-dev\n       Como ejemplo para sistemas NFS, las siguientes l\u00edneas  de  \u00f3rdenes  cambiar\u00edan  el  dispositivo  ra\u00edz  al\n       directorio  NFS  /var/nfsroot  en  un servidor NFS local con direcci\u00f3n IP 193.8.232.7 para un sistema con\n       direcci\u00f3n 193.8.232.7 llamado 'idefix':\n            echo /var/nfsroot >/proc/sys/kernel/nfs-root-name\n            echo 193.8.232.2:193.8.232.7::255.255.255.0:idefix \\\n              >/proc/sys/kernel/nfs-root-addrs\n            echo 255 >/proc/sys/kernel/real-root-dev\n\n", "UTILIZACI\u00d3N": "       La principal motivaci\u00f3n para implementar initrd fue la de permitir una configuraci\u00f3n modular  del  n\u00facleo\n       en el momento de la instalaci\u00f3n.\n\n       Aqu\u00ed se describe un posible escenario de la instalaci\u00f3n del sistema:\n\n         1.  El  programa  cargador  arranca desde disquete u otro medio con un n\u00facleo m\u00ednimo (p.ej. con soporte\n         para /dev/ram, /dev/initrd, y el sistema  de  ficheros  ext2)  y  carga  /dev/initrd  con  una  versi\u00f3n\n         comprimida (con gzip) del sistema de ficheros inicial.\n\n         2.  El  ejecutable  /linuxrc determina lo que se necesita para montar, mount(1), el sistema de ficheros\n         ra\u00edz normal (p.ej. tipo de dispositivo, controladores, sistema  de  ficheros)  y  (2)  el  formato  'de\n         distribuci\u00f3n'   (p.ej.  CD-ROM,  red,  cinta,  ...).  Esto  se  puede  hacer  preguntando  al  usuario,\n         tanteando/probando autom\u00e1ticamente, o mediante una aproximaci\u00f3n mixta.\n\n         3. El ejecutable /linuxrc carga los m\u00f3dulos necesarios desde el sistema de ficheros inicial.\n\n         4. El ejecutable /linuxrc crea y 'expande' el sistema de ficheros ra\u00edz. (En esta etapa, el sistema ra\u00edz\n         no tiene por qu\u00e9 ser a\u00fan un sistema completo.)\n\n         5.  El  ejecutable  /linuxrc  establece  /proc/sys/kernel/real-root-dev,  desmonta /proc, el sistema de\n         ficheros ra\u00edz y cualquier otro sist. de ficheros que hubiese montado, y entonces termina.\n\n         6. El n\u00facleo entonces monta el sistema de ficheros definitivo.\n\n         7. Ahora que el sist. de ficheros est\u00e1 accesible e intacto, el gestor de arranque puede ser instalado.\n\n         8. El gestor de arranque est\u00e1 configurado para cargarse en /dev/initrd, un sistema de ficheros  con  el\n         conjunto de m\u00f3dulos que fue utilizado para poner en marcha el sistema.  (p.ej. El dispositivo /dev/ram0\n         puede ser modificado, despu\u00e9s desmontado, y finalmente, la imagen  es  escrita  desde  /dev/ram0  a  un\n         fichero.)\n\n         9. El sistema es ahora capaz de arrancar, y se pueden abordar nuevas tareas de la instalaci\u00f3n.\n\n       El  papel  clave  de  /dev/initrd en el proceso es el de reutilizar los datos de configuraci\u00f3n durante el\n       funcionamiento habitual del sistema sin que se requiera una selecci\u00f3n inicial del  n\u00facleo,  o  un  n\u00facleo\n       gen\u00e9rico demasiado grande, o recompilarlo.\n\n       Un  segundo  escenario  se  presenta para instalaciones en las que Linux corre en sistemas con diferentes\n       configuraciones 'hardware' en una misma red.  En estos casos, puede ser deseable utilizar s\u00f3lo un peque\u00f1o\n       conjunto  de n\u00facleos (idealmente, uno) y mantener la parte espec\u00edfica de la configuraci\u00f3n de cada sistema\n       tan peque\u00f1a como sea posible.  En este caso, se crea un fichero com\u00fan con todos los  m\u00f3dulos  requeridos.\n       Entonces, s\u00f3lo el fichero /linuxrc o un fichero ejecutado por /linuxrc ser\u00eda diferente.\n\n       Un  tercer  ejemplo es m\u00e1s conveniente para discos 'de rescate'.  Debido a que cierta informaci\u00f3n como la\n       localizaci\u00f3n de la partici\u00f3n del sistema de ficheros ra\u00edz no se necesita en el momento del  arranque,  el\n       sistema  cargado desde /dev/initrd puede utilizar un di\u00e1logo y/o autodetecci\u00f3n seguido posiblemente de un\n       chequeo a este sistema de ficheros.\n\n       Por \u00faltimo, pero no menos importante, las distribuciones de Linux en CD-ROM pueden utilizar  initrd  para\n       facilitar  la  instalaci\u00f3n  desde  el  CD-ROM.   La  distribuci\u00f3n  puede  utilizar  LOADLIN  para  cargar\n       directamente /dev/initrd desde el CD-ROM sin necesitar ning\u00fan disquete.  La distribuci\u00f3n  podr\u00eda  tambi\u00e9n\n       utilizar  un  disco de arranque con LILO y despu\u00e9s cargar un disco-ram m\u00e1s grande a trav\u00e9s de /dev/initrd\n       desde el CD-ROM.\n\n", "CONFIGURACI\u00d3N": "       El dispositivo de bloques /dev/initrd es de s\u00f3lo lectura, al que se le asigna como n\u00famero mayor 1 y  como\n       n\u00famero  menor 250. T\u00edpicamente /dev/initrd es propiedad de root:disk con modo 0400 (con acceso de lectura\n       s\u00f3lo para el 'root').  Si el  sistema  no  tiene  creado  /dev/initrd  todav\u00eda,  puede  crearse  con  las\n       siguientes \u00f3rdenes:\n               mknod -m 400 /dev/initrd b 1 250\n               chown root.disk /dev/initrd\n       Tambi\u00e9n,  el  soporte  tanto  para  \"disco  RAM\"  y  \"disco  RAM  Inicial\" (p.ej.  CONFIG_BLK_DEV_RAM=y y\n       CONFIG_BLK_DEV_INITRD=y  )  debe  ser  compilado  directamente  en  el  n\u00facleo  de  Linux  para  utilizar\n       /dev/initrd.  Cuando se usa /dev/initrd, el controlador del disco RAM no se puede cargar como m\u00f3dulo.\n\n", "FICHEROS": "       /dev/initrd\n       /dev/ram0\n       /linuxrc\n       /initrd\n\nV\u00c9ASE TAMBI\u00c9N\n       chown(1),  mknod(1),  /dev/ram(4),  freeramdisk(8), rdev(8), El fichero de documentaci\u00f3n initrd.txt en el\n       paquete de  los  fuentes  del  n\u00facleo,  la  documentaci\u00f3n  de  LILO,  la  documentaci\u00f3n  de  LOADLIN,  la\n       documentaci\u00f3n de SYSLINUX.\n\n", "OBSERVACIONES": "       1.  Con el n\u00facleo actual, cualquier sistema de ficheros que permanezca montado cuando /dev/ram0 es movido\n       desde / a /initrd  contin\u00faa  siendo  accesible.  Sin  embargo,  la  informaci\u00f3n  en  /proc/mounts  no  es\n       actualizada.\n\n       2.  Con  el  n\u00facleo  actual, si el directorio /initrd no existe, entonces /dev/ram0 no ser\u00e1 completamente\n       desmontado si /dev/ram0 est\u00e1 siendo utilizado por alg\u00fan proceso o  mantiene  alg\u00fan  sistema  de  ficheros\n       montado en \u00e9l.  Si no se desmonta completamente /dev/ram0 , entonces /dev/ram0 permanecer\u00e1 en memoria.\n\n       3.  Los usuarios de /dev/initrd no deber\u00edan depender del comportamiento indicado en las notas anteriores.\n       Este comportamiento puede cambiar en futuras versiones del n\u00facleo de Linux.\n\n", "AUTOR": "       El  c\u00f3digo  del  n\u00facleo  para  el  dispositivo  initrd   ha   sido   escrito   por   Werner   Almesberger\n       <almesber@lrc.epfl.ch>  y  Hans  Lermen  <lermen@elserv.ffm.fgan.de>.  El c\u00f3digo para initrd se a\u00f1adi\u00f3 al\n       c\u00f3digo b\u00e1sico del n\u00facleo en la versi\u00f3n de desarrollo 1.3.73.\n\nLinux 2.0                                       6 Noviembre 1997                                       INITRD(4)\n"},{"NOMBRE": "       intro - Introducci\u00f3n a \u00f3rdenes de usuario\n\n", "DESCRIPCI\u00d3N": "       Este cap\u00edtulo describe \u00f3rdenes de usuario.\n\n", "AUTORES": "       Busque  en  la cabecera de cada p\u00e1gina del Manual el autor o autores y las condiciones sobre los derechos\n       de copia. \u00a1Observe que \u00e9stos pueden ser diferentes de una p\u00e1gina a otra!\n\nLinux                                          24 de Julio de 1993                                      INTRO(1)\n"},{"NOMBRE": "       mem, kmem, port - memoria del sistema, memoria del n\u00facleo y puertos del sistema.\n\n", "DESCRIPCI\u00d3N": "       mem  es  un  fichero de dispositivo de caracteres que representa a la memoria principal del ordenador. Se\n       puede utilizar, por ejemplo, para examinar (e incluso parchear) el sistema.\n\n       En mem, las direcciones de bytes se interpretan como direcciones f\u00edsicas de memoria.  Las  referencias  a\n       posiciones no existentes producen un error.\n\n       El  examinar  y  parchear posiciones de memoria que contienen bits de s\u00f3lo-lectura o s\u00f3lo-escritura puede\n       conducir a resultados inesperados.\n\n       Normalmente se crea con:\n\n              mknod -m 660 /dev/mem c 1 1\n              chown root:mem /dev/mem\n\n       El archivo kmem es id\u00e9ntico a mem, excepto que se accede a la memoria virtual del n\u00facleo, en vez de a  la\n       memoria f\u00edsica.\n\n       Normalmente se crea con:\n\n              mknod -m 640 /dev/kmem c 1 2\n              chown root:mem /dev/kmem\n\n       port es similar a mem, pero se accede a los puertos de E/S.\n\n       Normalmente se crea con:\n\n              mknod -m 660 /dev/port c 1 4\n              chown root:mem /dev/port\n\n", "FICHEROS": "       /dev/mem\n       /dev/kmem\n       /dev/port\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1), ioperm(2)\n\nLinux                                           21 Noviembre 1992                                         MEM(4)\n"},{"NAME": "       lp - print files\n\n", "SYNOPSIS": "       lp  [  -E  ] [ -U username ] [ -c ] [ -d destination[/instance] ] [ -h hostname[:port] ] [ -m ] [ -n num-\n       copies ] [ -o option[=value] ] [ -q priority ] [ -s ] [ -t title ] [ -H handling ] [ -P page-list ] [  --\n       ] [ file(s) ]\n       lp  [  -E  ]  [  -U  username  ]  [  -c ] [ -h hostname[:port] ] [ -i job-id ] [ -n num-copies ] [ -o op\u2010\n       tion[=value] ] [ -q priority ] [ -t title ] [ -H handling ] [ -P page-list ]\n\n", "DESCRIPTION": "       lp submits files for printing or alters a pending job.  Use a filename of \"-\" to force printing from  the\n       standard input.\n\n   THE DEFAULT DESTINATION\n       CUPS  provides many ways to set the default destination. The LPDEST and PRINTER environment variables are\n       consulted first.  If neither are set, the current default set using the  lpoptions(1)  command  is  used,\n       followed by the default set using the lpadmin(8) command.\n\n", "OPTIONS": "       The following options are recognized by lp:\n\n       --   Marks the end of options; use this to print a file whose name begins with a dash (-).\n\n       -E   Forces encryption when connecting to the server.\n\n       -U username\n            Specifies the username to use when connecting to the server.\n\n       -c   This  option  is  provided for backwards-compatibility only. On systems that support it, this option\n            forces the print file to be copied to the spool directory before printing.  In CUPS, print files are\n            always sent to the scheduler via IPP which has the same effect.\n\n       -d destination\n            Prints files to the named printer.\n\n       -h hostname[:port]\n            Chooses an alternate server.\n\n       -i job-id\n            Specifies an existing job to modify.\n\n       -m   Sends an email when the job is completed.\n\n       -n copies\n            Sets the number of copies to print.\n\n       -o \"name=value [ ... name=value ]\"\n            Sets one or more job options.  See \"COMMON JOB OPTIONS\" below.\n\n       -q priority\n            Sets the job priority from 1 (lowest) to 100 (highest).  The default priority is 50.\n\n       -s   Do not report the resulting job IDs (silent mode.)\n\n       -t \"name\"\n            Sets the job name.\n\n       -H hh:mm\n\n       -H hold\n\n       -H immediate\n\n       -H restart\n\n       -H resume\n            Specifies  when  the job should be printed.  A value of immediate will print the file immediately, a\n            value of hold will hold the job indefinitely, and a UTC time value (HH:MM) will hold the  job  until\n            the  specified UTC (not local) time.  Use a value of resume with the -i option to resume a held job.\n            Use a value of restart with the -i option to restart a completed job.\n\n       -P page-list\n            Specifies which pages to print in the document.  The list can contain a list of numbers  and  ranges\n            (#-#) separated by commas, e.g., \"1,3-5,16\".  The page numbers refer to the output pages and not the\n            document's original pages - options like \"number-up\" can affect the numbering of the pages.\n\n   COMMON JOB OPTIONS\n       Aside from the printer-specific options reported by the lpoptions(1) command, the following  generic  op\u2010\n       tions are available:\n\n       -o job-sheets=name\n            Prints  a  cover  page  (banner) with the document.  The \"name\" can be \"classified\", \"confidential\",\n            \"secret\", \"standard\", \"topsecret\", or \"unclassified\".\n\n       -o media=size\n            Sets the page size to size. Most printers support at least the size names \"a4\", \"letter\",  and  \"le\u2010\n            gal\".\n\n       -o number-up={2|4|6|9|16}\n            Prints 2, 4, 6, 9, or 16 document (input) pages on each output page.\n\n       -o orientation-requested=4\n            Prints the job in landscape (rotated 90 degrees counter-clockwise).\n\n       -o orientation-requested=5\n            Prints the job in landscape (rotated 90 degrees clockwise).\n\n       -o orientation-requested=6\n            Prints the job in reverse portrait (rotated 180 degrees).\n\n       -o print-quality=3\n\n       -o print-quality=4\n\n       -o print-quality=5\n            Specifies the output quality - draft (3), normal (4), or best (5).\n\n       -o sides=one-sided\n            Prints on one side of the paper.\n\n       -o sides=two-sided-long-edge\n            Prints on both sides of the paper for portrait output.\n\n       -o sides=two-sided-short-edge\n            Prints on both sides of the paper for landscape output.\n\nCONFORMING TO\n       Unlike  the System V printing system, CUPS allows printer names to contain any printable character except\n       SPACE, TAB, \"/\", or \"#\".  Also, printer and class names are not case-sensitive.\n\n       The -q option accepts a different range of values than the Solaris lp command, matching the IPP job  pri\u2010\n       ority  values  (1-100,  100 is highest priority) instead of the Solaris values (0-39, 0 is highest prior\u2010\n       ity).\n\n", "EXAMPLES": "       Print two copies of a document to the default printer:\n\n           lp -n 2 filename\n\n       Print a double-sided legal document to a printer called \"foo\":\n\n           lp -d foo -o media=legal -o sides=two-sided-long-edge filename\n\n       Print a presentation document 2-up to a printer called \"bar\":\n\n           lp -d bar -o number-up=2 filename\n\nSEE ALSO\n       cancel(1), lpadmin(8), lpoptions(1), lpq(1), lpr(1), lprm(1), lpstat(1), CUPS Online Help  (http://local\u2010\n       host:631/help)\n\n", "COPYRIGHT": "       Copyright \u00a9 2007-2019 by Apple Inc.\n\n26 April 2019                                         CUPS                                                 lp(1)\n"},{"NOMBRE": "       magic - fichero de n\u00fameros m\u00e1gicos para la orden file\n\n", "DESCRIPCI\u00d3N": "       Esta p\u00e1gina del Manual documenta el formato del fichero m\u00e1gico que emplea la orden file(1), versi\u00f3n 3.26.\n       La orden file identifica el tipo de un fichero utilizando, entre  otras  pruebas,  una  que  mira  si  el\n       fichero  empieza  con  un  cierto n\u00famero m\u00e1gico.  El fichero /usr/share/misc/magic especifica qu\u00e9 n\u00fameros\n       m\u00e1gicos hay que buscar, qu\u00e9 mensaje mostrar si se encuentra un n\u00famero m\u00e1gico en particular, e informaci\u00f3n\n       adicional que haya que extraer del fichero.\n\n       Cada  l\u00ednea  del fichero especifica una prueba a realizar.  Una prueba compara los datos que comiencen en\n       una posici\u00f3n particular en el fichero con un valor num\u00e9rico de 1, 2 \u00f3 4 bytes o una cadena de caracteres.\n       Si la prueba tiene \u00e9xito, se muestra un mensaje. La l\u00ednea consiste en los campos siguientes:\n\n       desplazamiento\n                Un  n\u00famero  que  especifica el desplazamiento, en bytes, desde el principio del fichero de datos\n                que se est\u00e9 comprobando.\n\n       tipo     El tipo de los datos a comprobar. Los valores posibles son:\n\n                byte     Un valor de un byte.\n\n                short    Un valor de dos bytes (en la mayor\u00eda de los sistemas) en el orden de bytes nativo de la\n                         m\u00e1quina.\n\n                long     Un valor de cuatro bytes (en la mayor\u00eda de los sistemas) en el orden de bytes nativo de\n                         la m\u00e1quina.\n\n                string   Una cadena de bytes.\n\n                date     Un valor de cuatro bytes interpretado como una fecha de Unix.\n\n                beshort  Un valor de dos bytes (en la mayor\u00eda de los sistemas) en  orden  de  bytes  ascendiente\n                         hacia la derecha.\n\n                belong   Un  valor  de cuatro bytes (en la mayor\u00eda de los sistemas) en orden de bytes ascendente\n                         hacia la derecha.\n\n                bedate   Un valor de cuatro bytes (en la mayor\u00eda de los sistemas) en orden de  bytes  ascendente\n                         hacia la derecha, interpretado como una fecha de Unix.\n\n                leshort  Un  valor  de  dos  bytes  (en la mayor\u00eda de los sistemas) en orden de bytes ascendente\n                         hacia la izquierda.\n\n                lelong   Un valor de cuatro bytes (en la mayor\u00eda de los sistemas) en orden de  bytes  ascendente\n                         hacia la izquierda.\n\n                ledate   Un  valor  de cuatro bytes (en la mayor\u00eda de los sistemas) en orden de bytes ascendente\n                         hacia la izquierda, interpretado como una fecha de Unix.\n\n       Los tipos num\u00e9ricos pueden opcionalmente ir seguidos por & y  un  valor  num\u00e9rico,  para  especificar  la\n       operaci\u00f3n  de  bits  Y  con dicho valor antes de que se realice la comparaci\u00f3n. Preceder el tipo de una u\n       indica que las comparaciones ordenadas deben hacerse sobre valores sin signo.\n\n       test   El valor a ser comparado con el valor  del  fichero.  Si  el  tipo  es  num\u00e9rico,  este  valor  se\n              especifica  como  en  el  lenguaje  C;  si  es  una  cadena,  como  una cadena de caracteres de C,\n              permiti\u00e9ndose las secuencias de escape habituales (como \\n para la nueva l\u00ednea).\n\n              Los valores num\u00e9ricos pueden  hacerse  preceder  por  un  car\u00e1cter  que  indique  la  operaci\u00f3n  a\n              realizarse.  Puede  ser =, para especificar que el valor del fichero debe igualar al especificado,\n              <, para especificar que el valor del fichero debe ser menor que el  valor  especificado,  >,  para\n              especificar que el valor del fichero debe ser mayor que el valor especificado, &, para especificar\n              que el valor del fichero debe tener a 1 todos los bits que est\u00e9n a 1 en el valor especificado,  ^,\n              para  especificar  que el valor del fichero debe tener a 0 cualquiera de los bits que est\u00e9n a 1 en\n              el valor especificado, o x, para especificar que cualquier valor concordar\u00e1.  Si  el  car\u00e1cter  se\n              omite, se asume que es =.\n\n              Los  valores  num\u00e9ricos se especifican como en C; por ejemplo, 13 es en base diez, 013 es octal, y\n              0x13 es hexadecimal.\n\n              Para valores de cadena, la cadena de bytes del fichero debe  concordar  con  la  cadena  de  bytes\n              especificada.   Los  operadores  =,  <  y  >  (pero no &) pueden aplicarse a cadenas.  La longitud\n              empleada para la concordancia es la del argumento cadena en el fichero m\u00e1gico. Esto significa  que\n              una  l\u00ednea  puede  concordar con cualquier cadena, y por tanto presumiblemente mostrarla, haciendo\n              >\\0 (porque todas las cadenas son mayores que la cadena nula).\n\n       mensaje\n              EL mensaje a mostrarse si la comparaci\u00f3n tiene \u00e9xito. Si la cadena contiene una especificaci\u00f3n  de\n              formato  como  las de printf(3S), el valor del fichero (con cualquier enmascaramiento especificado\n              ya realizado) se muestra empleando el mensaje como la cadena de formato.\n\n       Algunos formatos de fichero contienen informaci\u00f3n adicional  que  se  mostrar\u00e1  junto  con  el  tipo  del\n       fichero.  Una  l\u00ednea que comience con el car\u00e1cter > indica pruebas y mensajes a mostrarse adicionales. El\n       n\u00famero de > en la l\u00ednea indica el nivel de la prueba; una l\u00ednea sin ning\u00fan > al  principio  se  considera\n       que  est\u00e1  en  el nivel 0.  Cada l\u00ednea en el nivel n+1 est\u00e1 bajo el control de la l\u00ednea en el nivel n m\u00e1s\n       cercano que la preceda en el fichero m\u00e1gico.  Si la prueba en una l\u00ednea en el nivel  n  tiene  \u00e9xito,  se\n       realizan  las  pruebas  especificadas en todas las l\u00edneas subsiguientes en el nivel n+1 y se muestran los\n       mensajes si las pruebas tienen \u00e9xito. La l\u00ednea siguiente en el nivel n termina con esto.   Si  el  primer\n       car\u00e1cter  que  siga  al  \u00faltimo  >  es  un  ( entonces la cadena tras el par\u00e9ntesis se interpreta como un\n       desplazamiento indirecto. Eso significa que el n\u00famero tras el par\u00e9ntesis se emplea como un desplazamiento\n       en  el  fichero. Se lee el valor en tal desplazamiento, y se emplea de nuevo como un desplazamiento en el\n       fichero. Los desplazamientos indirectos son de la forma: ((x[.[bslBSL]][+-][y]).  El valor de x se emplea\n       como  un  desplazamiento  en  el  fichero.  Se  lee  en  tal  sitio un byte, un entero corto o uno largo,\n       dependiendo del especificador de tipo [bslBSL].  Los tipos en may\u00fasculas interpretan el  n\u00famero  como  un\n       valor  ascendente  hacia  la  derecha,  mientras  que  las  versiones  en  min\u00fasculas lo interpretan como\n       ascendente hacia la izquierda. A ese n\u00famero se le suma el valor de y y el resultado  se  emplea  como  un\n       desplazamiento en el fichero. El tipo predeterminado si no se especifica uno es long, un entero largo.\n\n       A  veces  uno no sabe la posici\u00f3n exacta puesto que \u00e9sta depende de la longitud de los campos anteriores.\n       Entonces se puede especificar un desplazamiento o posici\u00f3n relativa al final del \u00faltimo campo  del  nivel\n       superior  (por  supuesto esto s\u00f3lo puede hacerse para pruebas en subniveles, como en las que empiezan con\n       >).  Tal desplazamiento relativo se especifica empleando & como prefijo del desplazamiento.\n\n", "FALLOS": "       Los formatos long, belong, lelong, short, beshort, leshort, date, bedate, y ledate son  dependientes  del\n       sistema;  quiz\u00e1s  deber\u00edan  especificarse como un n\u00famero de bytes (2B, 4B, etc.), puesto que los ficheros\n       que se est\u00e1n reconociendo vienen normalmente de un sistema en el que las longitudes son invariantes.\n\n       No  hay  (actualmente)  soporte  para  que  se  empleen  datos  con  sexo  (endianess)  especificado   en\n       desplazamientos indirectos.\n\nV\u00c9ASE TAMBI\u00c9N\n       file(1) - la orden que lee este fichero.\n\n                                                 Dominio P\u00fablico                                        MAGIC(4)\n"},{"NOMBRE": "       mem, kmem, port - memoria del sistema, memoria del n\u00facleo y puertos del sistema.\n\n", "DESCRIPCI\u00d3N": "       mem  es  un  fichero de dispositivo de caracteres que representa a la memoria principal del ordenador. Se\n       puede utilizar, por ejemplo, para examinar (e incluso parchear) el sistema.\n\n       En mem, las direcciones de bytes se interpretan como direcciones f\u00edsicas de memoria.  Las  referencias  a\n       posiciones no existentes producen un error.\n\n       El  examinar  y  parchear posiciones de memoria que contienen bits de s\u00f3lo-lectura o s\u00f3lo-escritura puede\n       conducir a resultados inesperados.\n\n       Normalmente se crea con:\n\n              mknod -m 660 /dev/mem c 1 1\n              chown root:mem /dev/mem\n\n       El archivo kmem es id\u00e9ntico a mem, excepto que se accede a la memoria virtual del n\u00facleo, en vez de a  la\n       memoria f\u00edsica.\n\n       Normalmente se crea con:\n\n              mknod -m 640 /dev/kmem c 1 2\n              chown root:mem /dev/kmem\n\n       port es similar a mem, pero se accede a los puertos de E/S.\n\n       Normalmente se crea con:\n\n              mknod -m 660 /dev/port c 1 4\n              chown root:mem /dev/port\n\n", "FICHEROS": "       /dev/mem\n       /dev/kmem\n       /dev/port\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1), ioperm(2)\n\nLinux                                           21 Noviembre 1992                                         MEM(4)\n"},{"NOMBRE": "       mouse - Interfaz de rat\u00f3n serie\n\n", "CONFIGURACI\u00d3N": "       Los ratones serie se conectan a una l\u00ednea serie RS232/V24, v\u00e9ase ttys(4) para una descripci\u00f3n.\n\n", "DESCRIPCI\u00d3N": "   Introducci\u00f3n\n       El diagrama de conexi\u00f3n de un conector de 9 pines normal como el usado por un rat\u00f3n serie es:\n\n                                          pin   nombre   usado para\n                                            2     RX     Data\n                                            3     TX     -12 V, Imax = 10 mA\n                                            4    DTR     +12 V, Imax = 10 mA\n                                            7    RTS     +12 V, Imax = 10 mA\n                                            5    GND     Ground\n\n       Esta es la especificaci\u00f3n aunque, de hecho, 9 voltios son suficientes para la mayor\u00eda de los ratones.\n\n       El  driver del rat\u00f3n puede reconocer un rat\u00f3n poniendo la RTS a nivel bajo y subi\u00e9ndola de nuevo. Despu\u00e9s\n       de 14 ms el rat\u00f3n enviar\u00e1 0X4D ('M') en la l\u00ednea de datos. Despu\u00e9s de otros 63 ms, un rat\u00f3n de 3  botones\n       Microsoft-compatible enviar\u00e1 0x33 ('3').\n\n       El  movimiento  relativo  del rat\u00f3n es enviado como dx (un valor positivio indica derecha) y dy (un valor\n       positivo indica abajo). Ratones diferentes pueden operar a diferentes velocidades. Para  seleccionar  una\n       velocidad,  entre  los valores 9600, 4800, 2400 y 1200 bit/s, se escriben los dos caracteres que aparecen\n       en la tabla de abajo y se hace una pausa de 0.1 segundos. La  siguiente  tabla  muestra  las  velocidades\n       disponibles y las cadenas que las seleccionan:\n\n                                                  bit/s   string\n                                                  9600    *q\n                                                  4800    *p\n                                                  2400    *o\n                                                  1200    *n\n\n       El primer byte de un paquete de datos se puede usar para prop\u00f3sitos de sincronizaci\u00f3n.\n\n   Protocolo Microsoft\n       El protocolo Microsoft usa 1 bit de inicio, 7 bits de datos, no paridad y un bit de parada a la velocidad\n       de 1200 bits/seg.  Los datos se env\u00eda a RxD en paquetes de 3 bytes.  Los movimientos dx y dy son enviados\n       en complemento a dos, y el bit lb (rb) se pone a 1 cuando se presiona el bot\u00f3n izquierdo (derecho):\n\n                                     byte   d6   d5    d4    d3    d2    d1    d0\n                                     \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                        1   1    lb    rb    dy7   dy6   dx7   dx6\n                                        2   0    dx5   dx4   dx3   dx2   dx1   dx0\n                                        3   0    dy5   dy4   dy3   dy2   dy1   dy0\n\n   Protocolo Microsoft de 3 botones\n       El  rat\u00f3n original de Microsoft s\u00f3lo tiene dos botones.  No obstante, hay algunos ratones de tres botones\n       que tambi\u00e9n usan el protocolo Microsoft.  Presionar o soltar el tercer bot\u00f3n (bot\u00f3n  central)  se  indica\n       enviando  un paquete de movimiento zero y ning\u00fan bot\u00f3n presionado.  (Por tanto, a diferencia de los otros\n       dos botones, el estado del tercer bot\u00f3n no se indica en cada paquete.)\n\n   Protocolo Logitech\n       Los ratones serie Logitech de 3 botones usan una extensi\u00f3n diferente del protocolo Microsoft:  cuando  el\n       bot\u00f3n  central  est\u00e1  levantado,  se  env\u00eda  el paquete anterior de 3 bytes. Cuando el bot\u00f3n central est\u00e1\n       pulsado, se env\u00eda un paquete de 4 bytes donde el 4\u00ba byte tiene el valor 0x20 (o, al menos,  tiene  activo\n       el  bit 0x20). En particular, la pulsaci\u00f3n del bot\u00f3n central se indica como 0,0,0,0x20 cuando ning\u00fan otro\n       bot\u00f3n est\u00e1 pulsado.\n\n   Protocolo Mousesystems\n       El protocolo Mousesystems usa 1 bit de comienzo, 8 bits de datos, no paridad y dos bits de  parada  a  la\n       velocidad  de 1200 bits/seg.  Los datos se envian a RxD en paquetes de 5 bytes.  dx se env\u00eda como la suma\n       de los dos valores en complemento a dos, dy  se  env\u00eda  como  la  suma  negada  de  los  dos  valores  en\n       complemento a dos. El bit lb (mb, rb) se pone a 0 cuando se presiona el bot\u00f3n izquierdo(central,derecho):\n\n                              byte   d7    d6     d5     d4     d3     d2     d1     d0\n                              \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                 1   1     0      0      0      0      lb     mb     rb\n                                 2   0    dxa6   dxa5   dxa4   dxa3   dxa2   dxa1   dxa0\n                                 3   0    dya6   dya5   dya4   dya3   dya2   dya1   dya0\n                                 4   0    dxb6   dxb5   dxb4   dxb3   dxb2   dxb1   dxb0\n                                 5   0    dyb6   dyb5   dyb4   dyb3   dyb2   dyb1   dyb0\n\n       Los bytes 4 y 5 describen el cambio producido desde que se transmitieron los bytes 2 y 3.\n\n   Protocolo Sun\n       El  protocolo  Sun es la versi\u00f3n de 3 bytes del protocolo anterior Mousesystems de 5 bytes: los \u00faltimos 2\n       bytes no se env\u00edan.\n\n   Protocolo MM\n       El protocolo MM usa 1 bit de comienzo, 8 bits de datos, paridad impar y un bit de parada a  la  velocidad\n       de 1200 bits/seg. Los datos se env\u00edan a RxD en paquetes de 3 bytes. dx y dy se env\u00edan como un \u00fanico valor\n       con signo, donde el bit de signo indica un valor negativo. El bit lb (mb,  rb)  se  pone  a  1  cando  se\n       presiona el bot\u00f3n izquierdo (central, derecho):\n\n                                  byte   d7   d6    d5    d4    d3    d2    d1    d0\n                                  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                                     1   1     0     0    dxs   dys   lb    mb    rb\n                                     2   0    dx6   dx5   dx4   dx3   dx2   dx1   dx0\n                                     3   0    dy6   dy5   dy4   dy3   dy2   dy1   dy0\n\n", "FICHEROS": "       /dev/mouse\n              un enlace simbolico frecuentemente usado, que apunta a un dispositivo de raton.\n\nV\u00c9ASE TAMBI\u00c9N\n       ttys(4), gpm(8)\n\nLinux                                            10 Febrero 1996                                        MOUSE(4)\n"},{"NOMBRE": "       null, zero - sumidero de datos\n\n", "DESCRIPCI\u00d3N": "       Los datos escritos en los ficheros especiales null o zero se desechan.\n\n       La lectura del fichero especial null siempre devuelve \"fin de fichero (EOF)\", mientras que la lectura del\n       fichero zero siempre devuelve el caracteres \\0 (NULL).\n\n       null y zero se crean normalmente con:\n\n              mknod -m 666 /dev/null c 1 3\n              mknod -m 666 /dev/zero c 1 5\n              chown root:mem /dev/null /dev/zero\n\n", "OBSERVACIONES": "       Si estos dos ficheros no tienen permiso de lectura y escritura para todos los usuarios, muchos  programas\n       se comportar\u00e1n de manera extra\u00f1a.\n\n", "FICHEROS": "       /dev/null\n       /dev/zero\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1)\n\nLinux                                             30 Junio 1996                                          NULL(4)\n"},{"NOMBRE": "       mem, kmem, port - memoria del sistema, memoria del n\u00facleo y puertos del sistema.\n\n", "DESCRIPCI\u00d3N": "       mem  es  un  fichero de dispositivo de caracteres que representa a la memoria principal del ordenador. Se\n       puede utilizar, por ejemplo, para examinar (e incluso parchear) el sistema.\n\n       En mem, las direcciones de bytes se interpretan como direcciones f\u00edsicas de memoria.  Las  referencias  a\n       posiciones no existentes producen un error.\n\n       El  examinar  y  parchear posiciones de memoria que contienen bits de s\u00f3lo-lectura o s\u00f3lo-escritura puede\n       conducir a resultados inesperados.\n\n       Normalmente se crea con:\n\n              mknod -m 660 /dev/mem c 1 1\n              chown root:mem /dev/mem\n\n       El archivo kmem es id\u00e9ntico a mem, excepto que se accede a la memoria virtual del n\u00facleo, en vez de a  la\n       memoria f\u00edsica.\n\n       Normalmente se crea con:\n\n              mknod -m 640 /dev/kmem c 1 2\n              chown root:mem /dev/kmem\n\n       port es similar a mem, pero se accede a los puertos de E/S.\n\n       Normalmente se crea con:\n\n              mknod -m 660 /dev/port c 1 4\n              chown root:mem /dev/port\n\n", "FICHEROS": "       /dev/mem\n       /dev/kmem\n       /dev/port\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1), ioperm(2)\n\nLinux                                           21 Noviembre 1992                                         MEM(4)\n"},{"NOMBRE": "       ptmx y pts - pseudo-terminal maestra y esclava\n\n", "DESCRIPCI\u00d3N": "       El  fichero  /dev/ptmx  es  un  dispositivo  de  caracteres  con  n\u00famero mayor 5 y n\u00famero menor 2, creado\n       normalmente con modo 0666 y de propietario root.root.  Se utiliza para crear un par de  pseudo-terminales\n       maestra y esclava.\n\n       Cuando  un  proceso  abre  /dev/ptmx,  obtiene  un descriptor de fichero para una pseudo-terminal maestra\n       (PTM), y se crea un dispositivo pseudo-terminal esclavo (PTS) en el directorio /dev/pts.  Cada descriptor\n       de  fichero  obtenido  al  abrir /dev/ptmx es una PTM independiente con su propia PTS asociada, cuya ruta\n       puede ser consultada pasando el descriptor a la funci\u00f3n ptsname(3).\n\n       Antes de abrir la pseudo-terminal esclava, debe pasar el descriptor  de  fichero  de  la  pseudo-terminal\n       maestra a grantpt(3) y unlockpt(3).\n\n       Una  vez  que  la  pseudo-terminal  maestra  y  esclava  est\u00e1n abiertas, la pseudo-terminal esclava sirve\n       procesos con una interfaz id\u00e9ntica a la de una terminal real.\n\n       Los datos escritos en el esclavo se presentan en el descriptor maestro como entrada.  Los datos  escritos\n       en el maestro se presentan en el esclavo como entrada.\n\n       En  la  pr\u00e1ctica, las pseudo-terminales se usan para implementar emuladores de terminal como xterm(1), en\n       los cuales los datos le\u00eddos de la pseudo-terminal maestra son interpretados por la aplicaci\u00f3n de la misma\n       forma  que  una  terminal  real  los  interpretar\u00eda,  y  para implementar programas de acceso remoto como\n       sshd(8), en los cuales los datos le\u00eddos de la pseudo-terminal esclava se env\u00edan a trav\u00e9s  de  la  red  al\n       programa cliente que est\u00e1 conectado al terminal o emulador de terminal.\n\n       Las  pseudo-terminales se pueden emplear tambi\u00e9n para enviar la salida a los programas que normalmente se\n       niegan a leer la entrada de tuber\u00edas (como su(8), y passwd(8)).\n\n", "FICHEROS": "       /dev/ptmx, /dev/pts/*\n\n", "OBSERVACIONES": "       El soporte de Linux a todo lo anterior (conocido como sistema de nombres de pty's de Unix98)  se  realiza\n       usando el sistema de ficheros devpts, que debe montarse en /dev/pts.\n\n       Antes  de  este  esquema  de  Unix98,  las  pseudo-terminales maestras se llamaban /dev/ptyp0, ...  y las\n       esclavas /dev/ttyp0, ...  y era necesario tener ya creados y asignados  un  gran  n\u00famero  de  nodos-i  de\n       dispositivo.\n\nV\u00c9ASE TAMBI\u00c9N\n       getpt(3), grantpt(3), ptsname(3), unlockpt(3)\n\nLinux                                            9 octubre 2002                                           PTS(4)\n"},{"NOMBRE": "       ptmx y pts - pseudo-terminal maestra y esclava\n\n", "DESCRIPCI\u00d3N": "       El  fichero  /dev/ptmx  es  un  dispositivo  de  caracteres  con  n\u00famero mayor 5 y n\u00famero menor 2, creado\n       normalmente con modo 0666 y de propietario root.root.  Se utiliza para crear un par de  pseudo-terminales\n       maestra y esclava.\n\n       Cuando  un  proceso  abre  /dev/ptmx,  obtiene  un descriptor de fichero para una pseudo-terminal maestra\n       (PTM), y se crea un dispositivo pseudo-terminal esclavo (PTS) en el directorio /dev/pts.  Cada descriptor\n       de  fichero  obtenido  al  abrir /dev/ptmx es una PTM independiente con su propia PTS asociada, cuya ruta\n       puede ser consultada pasando el descriptor a la funci\u00f3n ptsname(3).\n\n       Antes de abrir la pseudo-terminal esclava, debe pasar el descriptor  de  fichero  de  la  pseudo-terminal\n       maestra a grantpt(3) y unlockpt(3).\n\n       Una  vez  que  la  pseudo-terminal  maestra  y  esclava  est\u00e1n abiertas, la pseudo-terminal esclava sirve\n       procesos con una interfaz id\u00e9ntica a la de una terminal real.\n\n       Los datos escritos en el esclavo se presentan en el descriptor maestro como entrada.  Los datos  escritos\n       en el maestro se presentan en el esclavo como entrada.\n\n       En  la  pr\u00e1ctica, las pseudo-terminales se usan para implementar emuladores de terminal como xterm(1), en\n       los cuales los datos le\u00eddos de la pseudo-terminal maestra son interpretados por la aplicaci\u00f3n de la misma\n       forma  que  una  terminal  real  los  interpretar\u00eda,  y  para implementar programas de acceso remoto como\n       sshd(8), en los cuales los datos le\u00eddos de la pseudo-terminal esclava se env\u00edan a trav\u00e9s  de  la  red  al\n       programa cliente que est\u00e1 conectado al terminal o emulador de terminal.\n\n       Las  pseudo-terminales se pueden emplear tambi\u00e9n para enviar la salida a los programas que normalmente se\n       niegan a leer la entrada de tuber\u00edas (como su(8), y passwd(8)).\n\n", "FICHEROS": "       /dev/ptmx, /dev/pts/*\n\n", "OBSERVACIONES": "       El soporte de Linux a todo lo anterior (conocido como sistema de nombres de pty's de Unix98)  se  realiza\n       usando el sistema de ficheros devpts, que debe montarse en /dev/pts.\n\n       Antes  de  este  esquema  de  Unix98,  las  pseudo-terminales maestras se llamaban /dev/ptyp0, ...  y las\n       esclavas /dev/ttyp0, ...  y era necesario tener ya creados y asignados  un  gran  n\u00famero  de  nodos-i  de\n       dispositivo.\n\nV\u00c9ASE TAMBI\u00c9N\n       getpt(3), grantpt(3), ptsname(3), unlockpt(3)\n\nLinux                                            9 octubre 2002                                           PTS(4)\n"},{"NOMBRE": "       ram - dispositivo de disco ram\n\n", "DESCRIPCI\u00d3N": "       ram es el dispositivo de bloque usado para acceder al disco ram en modo crudo (raw mode).\n\n       Normalmente se crea con:\n\n              mknod -m 660 /dev/ram b 1 1\n              chown root:disk /dev/ram\n\n", "FICHEROS": "       /dev/ram\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1), mount(8)\n\nLinux                                             30 Junio 1996                                           RAM(4)\n"},{"NOMBRE": "       random, srandom, initstate, setstate - generador de n\u00fameros aleatorios.\n\n", "SINOPSIS": "       #include <stdlib.h>\n\n       long int random(void);\n       void srandom(unsigned int seed);\n       char *initstate(unsigned int seed, char *state, size_t n);\n       char *setstate(char *state);\n\n", "DESCRIPCI\u00d3N": "       La  funci\u00f3n  random()  emplea  un generador no lineal aditivo con retroalimentaci\u00f3n de n\u00fameros aleatorios\n       utilizando una tabla  predeterminada  de  31  enteros  largos  para  devolver  n\u00fameros  pseudo-aleatorios\n       sucesivos en el rango de 0 a RAND_MAX.  El periodo de este generador de n\u00fameros aleatorios es muy grande,\n       aproximadamente 16*((2**31)-1).\n\n       La funci\u00f3n srandom() establece su argumento como la semilla de una  nueva  secuencia  de  enteros  seudo-\n       aleatorios  que ser\u00e1n devueltos por random() en secuencia.  Estas secuencias son repetibles si se llama a\n       srandom() con el mismo valor para la semilla. Si no se proporciona ninguna semilla, porque no se llama  a\n       srandom(), la funci\u00f3n random() autom\u00e1ticamente asume una semilla de valor 1.\n\n       La  funci\u00f3n  initstate()  permite  inicializar  un  vector  de  estado,  estado, para el uso por parte de\n       random().  El tama\u00f1o del vector de estado, n, es usado por initstate() para decidir cu\u00e1n sofisticado debe\n       ser  el  generador de n\u00fameros aleatorios que deber\u00eda usar: cuanto m\u00e1s grande sea el vector de estado, m\u00e1s\n       aleatorios ser\u00e1n los n\u00fameros. El argumento semilla es la semilla para la inicializaci\u00f3n,  que  especifica\n       un  punto  de  arranque  para  la  secuencia de n\u00fameros aleatorios, y hace posible recomenzar en el mismo\n       punto.\n\n       La funci\u00f3n setstate() cambia el vector de estado usado por la funci\u00f3n random().   El  vector  de  estado,\n       estado,  se  usa  para  la  generaci\u00f3n  de  n\u00fameros aleatorios hasta la siguiente llamada a initstate() o\n       setstate().  El argumento estado debe haber sido inicializado  primero  mediante  initstate()  o  ser  el\n       resultado de una llamada previa a setstate().\n\nVALOR DEVUELTO\n       La  funci\u00f3n  random()  devuelve  un valor entre 0 y RAND_MAX.  La funci\u00f3n srandom() no devuelve nada. Las\n       funciones initstate() y setstate() devuelven un puntero al vector de estado anterior, o NULL en  caso  de\n       error.\n\n", "ERRORES": "       EINVAL Se ha especificado un vector de estado de menos de 8 bytes para initstate().\n\n", "OBSERVACIONES": "       Los  valores  actuales \"\u00f3ptimos\" para el tama\u00f1o del vector de estado, n, son 8, 32, 64, 128, y 256 bytes;\n       otras cantidades ser\u00e1n redondeadas por abajo hasta la cantidad conocida m\u00e1s cercana. Utilizar menos de  8\n       bytes producir\u00e1 un error.\n\nCONFORME A\n       BSD 4.3\n\nV\u00c9ASE TAMBI\u00c9N\n       rand(3), srand(3)\n\nGNU                                              20 agosto 2000                                        RANDOM(3)\n"},{"NOMBRE": "       sd - controlador para las unidades de disco SCSI\n\n", "SINOPSIS": "       #include <linux/hdreg.h> /* para HDIO_GETGEO */\n       #include <linux/fs.h>    /* para BLKGETSIZE y BLKRRPART */\n\n", "CONFIGURACI\u00d3N": "       El  nombre  del dispositivo de bloque tiene la forma siguiente: sdlp ,donde l es una letra que designa la\n       unidad f\u00edsica, y p es un n\u00famero que designa la partici\u00f3n en dicha unidad f\u00edsica. A menudo, el  n\u00famero  de\n       partici\u00f3n, p, se omite cuando el dispositivo corresponde a la unidad entera.\n\n       Los  discos SCSI tienen un n\u00famero mayor de dispositivo de 8, y un n\u00famero menor de dispositivo de la forma\n       (16 * n\u00famero_unidad) + n\u00famero_partici\u00f3n, donde n\u00famero_unidad es el n\u00famero de la unidad  f\u00edsica  seg\u00fan  el\n       orden de detecci\u00f3n, y n\u00famero_partici\u00f3n se determina como sigue:\n\n       la partici\u00f3n 0 es la unidad entera\n       las particiones 1-4 son las particiones \"primarias\" DOS\n       las particiones 5-8 son las particiones \"extendidas\" (o \"l\u00f3gicas\") DOS\n\n       Por  ejemplo, /dev/sda tiene el n\u00famero mayor 8, menor 0, y se refiere a la primera unidad SCSI entera del\n       sistema. Y /dev/sdb3 tiene el n\u00famero mayor 8, menor 19, y se refiere a la  tercera  partici\u00f3n  \"primaria\"\n       DOS de la segunda unidad SCSI del sistema.\n\n       En  este momento s\u00f3lo est\u00e1n disponibles los dispositivos de bloque. Los dispositivos crudos (raw devices)\n       todav\u00eda no han sido implementados.\n\n", "DESCRIPCI\u00d3N": "       Las siguientes ioctl() est\u00e1n disponibles:\n\n       HDIO_GETGEO\n              Devuelve los par\u00e1metros del disco de la BIOS, en la siguiente estructura:\n                     struct hd_geometry {\n                           unsigned char heads;    /*N\u00famero de cabezas*/\n                           unsigned char sectors;  /*N\u00famero de sectores*/\n                           unsigned short cylinders;    /*N\u00famero de cilindros*/\n                           unsigned long start;    /*Principio del disco*/\n                     };\n\n              Se pasa un puntero a esta estructura como el par\u00e1metro de ioctl(2).\n\n              La informaci\u00f3n devuelta en el par\u00e1metro es la geometr\u00eda del disco de la unidad, \u00a1tal y como la  ve\n              el  DOS!   Esta  geometr\u00eda  no  es  la geometr\u00eda f\u00edsica de la unidad. No obstante, se utiliza para\n              construir la tabla de particiones de la unidad y es necesaria para el  adecuado  fucionamiento  de\n              fdisk(1),efdisk(1),  y lilo(1).  Si la informaci\u00f3n geom\u00e9trica no est\u00e1 disponible, todos los campos\n              de la estructura son cero.\n\n       BLKGETSIZE\n              Devuelve el tama\u00f1o del dispositivo en sectores. El par\u00e1metro de ioctl(2) debe  ser  un  puntero  a\n              long.\n\n       BLKRRPART\n              Fuerza la relectura de la tabla de particiones del disco SCSI. No se necesita ning\u00fan par\u00e1metro.\n\n              Tambi\u00e9n  se soportan las ioctl scsi(4).  Si se requiere el par\u00e1metro para ioctl(2) y \u00e9ste es NULL,\n              entonces ioctl(2) devolver\u00e1 -EINVAL.\n\n", "FICHEROS": "       /dev/sd[a-h]: el dispositivo completo\n       /dev/sd[a-h][0-8]: particiones de bloque individuales\n\nV\u00c9ASE TAMBI\u00c9N\n       scsi(4)\n\nLinux                                             2 Julio 1996                                             SD(4)\n"},{"NOMBRE": "       st - dispositivo de cinta magn\u00e9tica SCSI\n\n", "SINOPSIS": "       #include <sys/mtio.h>\n\n       int ioctl(int fd, int request [, (void *)arg3]);\n       int ioctl(int fd, MTIOCTOP, (struct mtop *)mt_cmd);\n       int ioctl(int fd, MTIOCGET, (struct mtget *)mt_status);\n       int ioctl(int fd, MTIOCPOS, (struct mtpos *)mt_pos);\n\n", "DESCRIPCI\u00d3N": "       El  manejador  (driver)  st  proporciona la interfaz para una variedad de dispositivos de cinta magn\u00e9tica\n       SCSI. Actualmente, toma el control de todos los dispositivos detectados de tipo \u201cacceso secuencial\u201d.   El\n       manejador st emplea el n\u00famero mayor de dispositivo 9.\n\n       Cada  dispositivo  utiliza  ocho  n\u00fameros menores de dispositivo. Los cinco bits m\u00e1s bajos en los n\u00fameros\n       menores se asignan secuencialmente en el orden en que se detectan. Los n\u00fameros menores se pueden  agrupar\n       en  dos conjuntos de cuatro n\u00fameros: los n\u00fameros menores de dispositivo (con autorebobinado) principales,\n       n, y los n\u00fameros de dispositivo \u201csin rebobinado\u201d, (n+128).  A los dispositivos abiertos que  utilicen  el\n       n\u00famero  de  dispositivo  principal se les enviar\u00e1 una orden REWIND cuando se cierren.  A los dispositivos\n       abiertos que utilicen el n\u00famero de dispositivo \u201csin rebobinado\u201d no  se  les  enviar\u00e1  esa  orden.   (Dese\n       cuenta  que  usar  un  dispositivo  con  autorebobinado  para posicionar la cinta con, por ejemplo, mt no\n       produce el resultado deseado: la cinta se rebobina despu\u00e9s de la orden mt y la orden  siguiente  comienza\n       desde el principio de la cinta).\n\n       Dentro  de  cada  grupo,  hay disponibles cuatro n\u00fameros menores para definir dispositivos con diferentes\n       caracter\u00edsticas (tama\u00f1o de bloque, compresi\u00f3n, densidad, etc.). Cuando  el  sistema  arranca,  s\u00f3lo  est\u00e1\n       disponible  el  primer  dispositivo.  Los  otros tres se activan cuando se definen las carcter\u00edsticas por\n       defecto (ver m\u00e1s abajo). (Cambiando las constantes en  tiempo  de  compilaci\u00f3n,  es  posible  cambiar  el\n       equilibrio  entre  el n\u00famero m\u00e1ximo de unidades de cinta y el n\u00famero de n\u00fameros menores para cada unidad.\n       La asignaci\u00f3n por defecto permite controlar 32 dispositivos de cinta. Por ejemplo, es  posible  controlar\n       hasta 64 unidades de cinta con 2 n\u00fameros menores para diferentes opciones).\n\n       Normalmente los dispositivos se crean con:\n              mknod -m 666 /dev/st0 c 9 0\n              mknod -m 666 /dev/st0l c 9 32\n              mknod -m 666 /dev/st0m c 9 64\n              mknod -m 666 /dev/st0a c 9 96\n              mknod -m 666 /dev/nst0 c 9 128\n              mknod -m 666 /dev/nst0l c 9 160\n              mknod -m 666 /dev/nst0m c 9 192\n              mknod -m 666 /dev/nst0a c 9 224\n\n       No existe el dispositivo de bloque correspondiente.\n\n       El  manejador  usa un buffer interno que tiene que ser lo suficientemente grande para contener, al menos,\n       un bloque de la cinta. En los n\u00facleos anteriores  al  2.1.121,  el  buffer  se  reserva  como  un  bloque\n       contiguo. Esto limita el tama\u00f1o de bloque al mayor bloque contiguo de memoria que el c\u00f3digo de asignaci\u00f3n\n       de memoria del n\u00facleo puede proporcionar. Actualmente, el l\u00edmite es de 128KB  para  arquitecturas  de  32\n       bits  y  256KB  para  arquitecturas  de 64 bits. En n\u00facleos posteriores el manejador reserva el buffer en\n       varias partes si es necesario. Por defecto, el n\u00famero m\u00e1ximo de partes es de 16.  Esto significa  que  el\n       tama\u00f1o m\u00e1ximo de bloques es muy grande (2MB si es posible una asignaci\u00f3n de 16 bloques de 128KB).\n\n       El  tama\u00f1o  del  buffer interno del manejador viene determinado por una contante en tiempo de compilaci\u00f3n\n       que se puede alterar con una opci\u00f3n de inicio del n\u00facleo.  Aparte de esto, el manejador intenta  reservar\n       un  buffer temporal mayor en tiempo de ejecuci\u00f3n si es necesario. Sin embargo, la asignaci\u00f3n en tiempo de\n       ejecuci\u00f3n de grandes bloques contiguos de memoria puede fallar y es aconsejable no confiar  demasiado  en\n       la  asignaci\u00f3n  din\u00e1mica  de buffers con n\u00facleos anteriores al 2.1.121 (esto se aplica tambi\u00e9n a la carga\n       por demanda del manejador con kerneld o kmod).\n\n       El manejador no soporta espec\u00edficamente ninguna marca o modelo de unidad de cinta. Despu\u00e9s  del  arranque\n       del sistema se definen las opciones de los dispositivos de cinta a partir del firmware de la unidad.  Por\n       ejemplo, si el firmware de la unidad selecciona un modo de bloque fijo, el dispositivo de  cinta  usa  el\n       modo  de  bloque  fijo.  Las  opciones  se  pueden cambiar con llamadas expl\u00edcitas a ioctl() y permanecen\n       activas cuando el dispositivo se cierra y se vuelve a abrir. La  configuraci\u00f3n  de  las  opciones  afecta\n       tanto al dispositivo con auto-rebobinado como sin rebobinado.\n\n       Se  pueden  indicar diferentes opciones para los diferentes dispositos dentro del subgrupo de cuatro. Las\n       opciones entran en vigor cuando el dispositivo se abre. Por ejemplo, el administrador del  sistema  puede\n       definir  un  dispositivo  que  escribe en modo de bloque fijo con un tama\u00f1o de bloque concreto y otro que\n       escribe en modo de bloque variable (si la unidad de cinta soporta ambos modos).\n\n       El majenador soporta particiones de cinta  si  son  soportadas  por  la  unidad.  (Dese  cuenta  que  las\n       particiones de cinta no tienen nada que ver con las particiones de disco. Una cinta particionada se puede\n       ver como varias cintas l\u00f3gicas dentro de un mismo medio). El soporte de particiones se debe habilitar con\n       ioctl.  La  posici\u00f3n  de  cinta se conserva dentro de cada partici\u00f3n durante los cambios de partici\u00f3n. La\n       partici\u00f3n usada para las operaciones de cinta  subsiguientes  se  selecciona  con  ioctl.  El  cambio  de\n       partici\u00f3n  se  ejecuta  junto  con  la  siguiente  operaci\u00f3n  de  cinta  para evitar movimientos de cinta\n       innecesarios.  El n\u00famero m\u00e1ximo de particiones en una cinta es definido por una constante  en  tiempo  de\n       compilaci\u00f3n  (originalmente cuatro). El manejador contiene un ioctl que puede formatear una cinta con una\n       o dos particiones.\n\n       El dispositivo /dev/tape se crea normalmente como un enlace f\u00edsico o simb\u00f3lico al  dispositivo  de  cinta\n       predeterminado en el sistema.\n\nTRANSFERENCIA DE DATOS\n       El  manejador  soporta tanto el funcionamiento en modo de bloque fijo como en modo de bloque variable (si\n       la unidad lo soporta). En el modo de bloque fijo la unidad escribe bloques del tama\u00f1o especificado  y  el\n       tama\u00f1o  de  bloque no depende de la cantidad de bytes de las llamadas al sistema de escritura. En el modo\n       de bloque variable se escribe un bloque de cinta para cada llamada de escritura  y  el  n\u00famero  de  bytes\n       determina  el  tama\u00f1o  del  bloque  de  cinta correspondiente. Dese cuenta que los bloques en la cinta no\n       contienen ninguna informaci\u00f3n sobre el modo de escritura: cuando se lee,  lo  \u00fanico  importante  es  usar\n       \u00f3rdenes que acepten los tama\u00f1os de los bloques en la cinta.\n\n       En el modo de bloque variable la cantida de bytes le\u00eddos no tiene que coincidir exactamente con el tama\u00f1o\n       de bloque de la cinta. Si la cantidad de bytes es mayor que el siguiente bloque de la cinta, el manejador\n       devuelve los datos y la funci\u00f3n devuelve el tama\u00f1o real de bloque. Si el tama\u00f1o de bloque es mayor que la\n       cantidad de bytes, se devuelve la cantidad de datos solicitada desde el inicio del bloque y el resto  del\n       bloque se descarta.\n\n       En  el  modo  de  bloque  fijo, la cantidad de bytes a leer puede ser arbitraria si se habilita el uso de\n       buffers, o un m\u00faltiplo del tama\u00f1o de bloque de la cinta si se deshabilita el uso de buffers. Los  n\u00facleos\n       anteriores  al  2.1.121  permiten escrituras con cantidades de bytes arbitrarias si se habilita el uso de\n       buffers. En todos los otros casos (un n\u00facleo anterior al 2.1.121 con uso de buffers  deshabilitado  o  un\n       n\u00facleo nuevo) la cantidad de bytes a escribir debe ser un m\u00faltiplo del tama\u00f1o de bloque de la cinta.\n\n       Autom\u00e1ticamente  se  escribe  una  marca  de fichero en la cinta si la \u00faltima operaci\u00f3n de cinta antes de\n       cerrar era un escritura.\n\n       Cuando se encuentra una marca de fichero durante las lecturas, ocurre lo siguiente. Si quedan datos en el\n       buffer  cuando  se  encuentra  la marca de fichero, se devuelven los datos del buffer. La pr\u00f3xima lectura\n       devuelve cero bytes. La siguiente lectura devuelve datos del siguiente fichero.  El final  de  los  datos\n       grabados  se indica devolviendo cero bytes para dos lecturas consecutivas. La tercera lectura devuelve un\n       error.\n\n", "IOCTLS": "       El manejador admite tres peticiones ioctl.  Las peticiones no reconocidas por el manejador st se pasan al\n       manejador SCSI.  Las definiciones de abajo son de /usr/include/linux/mtio.h:\n\n   MTIOCTOP - Efectuar una operaci\u00f3n en la cinta\n       Esta  petici\u00f3n  toma  un argumento de tipo (struct mtop *).  No todas las unidades de cinta admiten todas\n       las operaciones.  El manejador retorna un error EIO si la unidad rechaza una operaci\u00f3n.\n\n       /* Estructura para MTIOCTOP - orden de op. de cinta mag.: */\n       struct mtop {\n           short  mt_op;    /* operationes definidas abajo */\n           int    mt_count; /* cu\u00e1ntas de ellas */\n       };\n\n       Operaciones de Cinta Magn\u00e9tica para el uso normal de una cinta:\n       MTBSF         Espacio atr\u00e1s sobre mt_count marcas de fichero.\n       MTBSFM        Espacio atr\u00e1s sobre mt_count marcas de fichero.  Reposiciona la cinta a la parte EOT de  la\n                     \u00faltima marca de fichero.\n       MTBSR         Espacio atr\u00e1s sobre mt_count registros (bloques de cinta).\n       MTBSS         Espacio atr\u00e1s sobre mt_count marcas de conjunto.\n       MTCOMPRESSION Habilita  la compresi\u00f3n de los datos de la cinta dentro de la unidad si mt_count no es cero\n                     y deshabilita la compresi\u00f3n si mt_count es cero. Esta orden usa el MODO  p\u00e1gina  15  (`MODE\n                     page 15') soportado por la mayor\u00eda de DATs.\n       MTEOM         Ir al fin del material grabado (para a\u00f1adir ficheros).\n       MTERASE       Borrar cinta.\n       MTFSF         Espacio atr\u00e1s sobre mt_count marcas de fichero.\n       MTFSFM        Espacio  atr\u00e1s sobre mt_count marcas de fichero.  Reposiciona la cinta a la parte BOT de la\n                     \u00faltima marca de fichero.\n       MTFSR         Espacio atr\u00e1s sobre mt_count registros (bloques de cinta).\n       MTFSS         Espacio atr\u00e1s sobre mt_count marcas de conjunto.\n       MTLOAD        Ejecuta la orden SCSI de carga. Se dispone de un caso especial para algunos  autocargadores\n                     HP.  Si  mt_count es la constante MT_ST_HPLOADER_OFFSET m\u00e1s un n\u00famero, el n\u00famero se envia a\n                     la unidad para controlar al autocargador.\n       MTLOCK        Bloquea la puerta de la unidad de cinta.\n       MTMKPART      Formatea la cinta en una o dos particiones. Si mt_count no es cero,  da  el  tama\u00f1o  de  la\n                     primera  partici\u00f3n  y  la  segunda  partici\u00f3n contiene el resto de la cinta. Si mt_count es\n                     cero, la cinta se formatea en una partici\u00f3n.  Esta orden no est\u00e1 permitida para una  unidad\n                     a  menos que se habilite el soporte de particiones para la unidad (ver MT_ST_CAN_PARTITIONS\n                     m\u00e1s abajo).\n       MTNOP         No op. - vuelca el b\u00fafer del manejador como efecto colateral.  Deber\u00eda emplearse  antes  de\n                     leer el estado con MTIOCGET.\n       MTOFFL        Rebobina y apaga la unidad.\n       MTRESET       Pone la unidad en el estado inicial.\n       MTRETEN       Retensiona la cinta.\n       MTREW         Rebobina.\n       MTSEEK        Busca  y va al n\u00famero de bloque especificado en mt_count.  Esta operaci\u00f3n requiere bien una\n                     unidad SCSI-2 que admita la orden LOCATE (direcci\u00f3n espec\u00edfica del dispositivo),  bien  una\n                     unidad  SCSI-1 compatible con Tandberg (Tandberg, Archive Viper, Wangtek, ... ).  El n\u00famero\n                     de bloque deber\u00eda ser uno previamente devuelto por  MTIOCPOS  si  se  utilizan  direcciones\n                     espec\u00edficas del dispositivo.\n       MTSETBLK      Establece  la  longitud  de  bloque  de  la  unidad al valor especificado en mt_count.  Una\n                     longitud de bloque cero pone la unidad en modo de tama\u00f1o de bloque variable.\n       MTSETDENSITY  Pone la densidad de la cinta  seg\u00fan  el  c\u00f3digo  en  mt_count.   Los  c\u00f3digos  de  densidad\n                     soportados por una unidad se pueden encontrar en la documentaci\u00f3n de la unidad.\n       MTSETPART     La  partici\u00f3n  activa  se cambia a mt_count .  Las particiones se numeran a partir de cero.\n                     Esta orden no se permite para una unidad a menos que se habilite el soporte de  particiones\n                     para la unidad (ver MT_ST_CAN_PARTITIONS m\u00e1s abajo).\n       MTUNLOAD      Ejecuta la orden SCSI de descarga (no expulsa la cinta).\n       MTUNLOCK      Desbloquea la puerta de la unidad de cinta.\n       MTWEOF        Escribe mt_count marcas de fichero.\n       MTWSM         Escribe mt_count marcas de conjunto.\n\n       Operaciones  de  Cinta  Magn\u00e9tica  para  configurar  las  opciones  del  dispositivo  (a  realizar por el\n       superusuario):\n       MTSETDRVBUFFER\n               Establece varias opciones de la unidad y el manejador seg\u00fan los  bits  codificados  en  mt_count.\n               \u00c9stas  consisten  en el modo de uso de buffers de la unidad, 13 opciones booleanas del manejador,\n               el umbral de escritura del buffer, valores por defecto del tama\u00f1o  de  bloque  y  de  densidad  y\n               plazos de tiempo (s\u00f3lo en n\u00facleos >= 2.1).  Una \u00fanica operaci\u00f3n puede afectar a un \u00fanico elemento\n               de la lista de debajo (los booleanos cuentan como un elemento).\n\n               Un valor que tenga ceros en los 4  bits  m\u00e1s  altos  se  emplear\u00e1  para  establecer  el  modo  de\n               tamponamiento de la unidad.  Los modos de tamponamiento son:\n\n                   0   La  unidad  no informar\u00e1 del estado GOOD en \u00f3rdenes de escritura hasta que los bloques de\n                       datos se escriban realmente en el material magn\u00e9tico.\n                   1   La unidad puede devolver un estado GOOD en \u00f3rdenes de escritura tan pronto como todos los\n                       datos se hayan transferido al b\u00fafer interno de la unidad.\n                   2   La unidad puede devolver un estado GOOD en \u00f3rdenes de escritura tan pronto como (a) todos\n                       los datos se hayan transferido al b\u00fafer interno del manejador, y (b) todos los  datos  en\n                       b\u00faferes,  provinientes de iniciadores diferentes, hayan sido bien escritos en el material\n                       magn\u00e9tico.\n\n               Para controlar  el  umbral  de  escritura,  el  valor  en  mt_count  debe  incluir  la  constante\n               MT_ST_WRITE_THRESHOLD  aplic\u00e1ndole el operador de bits O inclusivo con un n\u00famero de bloque en los\n               28 bits de m\u00e1s bajo orden.  El n\u00famero de bloque se refiere a bloques de 1024 bytes, no al  tama\u00f1o\n               de  bloque  f\u00edsico  de  la  cinta.   El  umbral  no puede exceder el tama\u00f1o del b\u00fafer interno del\n               manejador (vea DESCRIPCI\u00d3N, arriba).\n\n               Para activar y desactivar las opciones booleanas el valor en mt_count debe  incluir  una  de  las\n               constantes MT_ST_BOOLEANS, MT_ST_SETBOOLEANS, MT_ST_CLEARBOOLEANS o MT_ST_BOOLEANS operada con un\n               O l\u00f3gico inclusivo a nivel de bits con cualquier combinaci\u00f3n de las siguientes opciones, seg\u00fan se\n               desee.   Usando MT_ST_BOOLEANS se pueden asignar a las opciones los valores definidos en los bits\n               correspondientes. Con MT_ST_SETBOOLEANS se pueden configurar las opciones de  forma  selectiva  y\n               selectivamente borradas con MT_ST_DEFBOOLEANS.\n\n               Las  opciones  por  defecto  para un dispositivo de cinta se configuran con MT_ST_DEFBOOLEANS. Un\n               dispositivo de cinta no activo (por ejemplo, un dispositivo con n\u00famero menor 32 o 160) se  activa\n               cuando  sus  opciones por defecto se definen por primera vez. Un dispositivo activado herenda del\n               dispositivo activado durante el arranque las opciones no configuradas expl\u00edcitamente.\n\n               Las opciones booleanas son:\n\n               MT_ST_BUFFER_WRITES  (Por omisi\u00f3n: verdad)\n                      Todas las operaciones de escritura van a trav\u00e9s de b\u00faferes en el modo de bloque fijo.   Si\n                      esta  opci\u00f3n  es  falsa  y  la  unidad emplea un tama\u00f1o de bloque fijo, entonces todas las\n                      operaciones de escritura deben ser un m\u00faltiplo del tama\u00f1o  de  bloque.  Esta  opci\u00f3n  debe\n                      ponerse como falsa para escribir confiablemente archivos multivol\u00famenes.\n               MT_ST_ASYNC_WRITES  (Por omisi\u00f3n: verdad)\n                      Cuando  esta  opci\u00f3n  es  verdad, las operaciones de escritura regresan inmediatamente sin\n                      esperar que los datos se transfieran a la unidad si  los  datos  caben  en  el  b\u00fafer  del\n                      manejador.   El  umbral de escritura determina cu\u00e1n lleno debe estar el b\u00fafer antes de que\n                      se d\u00e9 una nueva orden de escritura SCSI.   Cualquier  error  devuelto  por  la  unidad  se\n                      mantendr\u00e1  en  espera  hasta  la siguiente operaci\u00f3n.  Esta opci\u00f3n debe ponerse como falsa\n                      para escribir confiablemente archivos multivol\u00famenes.\n               MT_ST_READ_AHEAD  (Por omisi\u00f3n: verdad)\n                      Esta opci\u00f3n hace que el manejador proporcione un b\u00fafer para  la  lectura,  y  lectura  por\n                      adelantado  en  el  modo  de  bloque  fijo.  Si esta opci\u00f3n es falsa y la unidad emplea un\n                      tama\u00f1o de bloque fijo, entonces todas  las  operaciones  de  lectura  deben  ser  para  un\n                      m\u00faltiplo del tama\u00f1o de bloque.\n               MT_ST_TWO_FM  (Por omisi\u00f3n: falso)\n                      Esta  opci\u00f3n  modifica  el  comportamiento  del  manejador cuando un fichero se cierra. La\n                      acci\u00f3n normal es escribir una simlpe marca de fichero. Si la opci\u00f3n es verdad el manejador\n                      escribir\u00e1 dos marcas de fichero y har\u00e1 un espacio atr\u00e1s sobre el segundo.\n\n                      Nota:  Esta  opci\u00f3n  no deber\u00eda ponerse a verdad para unidades de cinta QIC puesto que son\n                      incapaces de sobreescribir una marca de fichero.  Estas unidades detectan el fin de  datos\n                      grabados  mirando  si hay cinta en blanco en vez de dos marcas de fichero consecutivas. La\n                      mayor\u00eda de las otras unidades actuales tambi\u00e9n detectan el final de los datos  grabados  y\n                      el  uso  de dos marcas de fichero es normalmente necesario s\u00f3lo al intercambiar cintas con\n                      algunos otros sistemas.\n\n               MT_ST_DEBUGGING  (Por omisi\u00f3n: falso)\n                      Esta opci\u00f3n activa varios mensajes de depuraci\u00f3n del manejador (s\u00f3lo  es  efectiva  si  se\n                      compil\u00f3 la unidad con DEBUG definida a un valor no cero).\n               MT_ST_FAST_EOM  (Por omisi\u00f3n: falso)\n                      Esta  opci\u00f3n  hace  que  la  operaci\u00f3n MTEOM se env\u00ede directamente a la unidad, acelerando\n                      potencialmente la operaci\u00f3n pero haciendo que el manejador pierda la pista del  n\u00famero  de\n                      fichero  en  curso  normalmente  devuelto  por la petici\u00f3n MTIOCGET.  Si MT_ST_FAST_EOM es\n                      falso el manejador responder\u00e1 a una petici\u00f3n  MTEOM  saltando  hacia  adelante  sobre  los\n                      ficheros.\n               MT_ST_AUTO_LOCK (Por omisi\u00f3n: falso)\n                      Cuando  esta  opci\u00f3n  es  verdad,  la  puerta  de  la  unidad se bloquea cuando se abre el\n                      dispositivo y se desbloquea cuando se cierra.\n               MT_ST_DEF_WRITES (Por omisi\u00f3n: falso)\n                      Las opciones de cinta (tama\u00f1o de bloque, modo, compresi\u00f3n, etc.) pueden cambiar al cambiar\n                      de  un  dispositivo  ligado  a  una  unidad  a  otro  dispositivo ligado a la misma unidad\n                      dependiendo de c\u00f3mo se  definan  los  dispositivos.   Esta  opci\u00f3n  define  cu\u00e1ndo  es  el\n                      manejador  el  que  fuerza  los  cambios  usando  \u00f3rdenes  SCSI  y c\u00faando se conf\u00eda en las\n                      capacidades del autodetecci\u00f3n de las unidades. Si esta opci\u00f3n es falsa, el manejador env\u00eda\n                      inmediatamente \u00f3rdenes SCSI cuando se cambia el dispositivo. Si la opci\u00f3n es verdad, no se\n                      env\u00edan \u00f3rdenes SCSI hasta que se solicite una  escritura.  En  este  caso  se  permite  al\n                      firmware  de  la  unidad  detectar  la  estructura  de la cinta al leer y s\u00f3lo se usan las\n                      \u00f3rdenes SCSI para asegurarse de que una cinta se escribe seg\u00fan la especificaci\u00f3n correcta.\n               MT_ST_CAN_BSR (Por omisi\u00f3n: falso)\n                      Algunas veces, cuando se usa lectura por adelantado,  se  debe  retrocer  la  cinta  a  la\n                      posici\u00f3n  correcta  cuando  se cierra el dispositivo y, para este prop\u00f3sito, se utiliza la\n                      orden SCSI para retrocer sobre los registros. Algunas  unidades  m\u00e1s  antiguas  no  pueden\n                      procesar  esta orden de manera fiable y se puede usar esta opci\u00f3n para mandar al manejador\n                      no usar la orden. El resultado final es que, con lectura  por  adelantado  y  el  modo  de\n                      bloque  fijo,  la  cinta  podr\u00eda  no  estar correctamente posicionada dentro de un fichero\n                      cuando el dispositivo se cierra.\n               MT_ST_NO_BLKLIMS (Por omisi\u00f3n: falso)\n                      Algunas unidades no aceptan la orden SCSI READ BLOCK LIMITS. Si se usa esto, el  manejador\n                      no usar\u00e1 la orden. El inconveniente es que el manejador no puede comprobar antes de enviar\n                      \u00f3rdenes si el tama\u00f1o de bloque seleccionado es aceptable por la unidad.\n               MT_ST_CAN_PARTITIONS (Por omisi\u00f3n: falso)\n                      Esta opci\u00f3n habilita el soporte de varias particiones dentro de una cinta.  La  opci\u00f3n  se\n                      aplica a todos los dispositivos ligados a la unidad.\n               MT_ST_SCSI2LOGICAL (Default: false)\n                      Esta  opci\u00f3n obliga al manejador a usar las direcciones l\u00f3gicas de bloques definidas en el\n                      est\u00e1ndar SCSI-2 al realizar la b\u00fasqueda y comunicar operaciones (tanto con la \u00f3rden MTSEEK\n                      como  con  MTIOCPOS  y  al  cambiar  la  partici\u00f3n de la cinta). En otro caso, se usan las\n                      direcciones espec\u00edficas del dispositivo. Es muy recomendable activar  esta  opci\u00f3n  si  la\n                      unidad  soporta  direcciones l\u00f3gicas ya que tambi\u00e9n cuentan marcas de fichero. Hay algunos\n                      dispositivos que s\u00f3lo soportan direcciones l\u00f3gicas de bloque.\n               MT_ST_SYSV (Por omisi\u00f3n: falso)\n                      Cuando se habilita esta opci\u00f3n, los dispositivos de cinta usan la sem\u00e1ntica de SystemV. En\n                      caso  contrario,  se  usa  la  sem\u00e1ntica  BSD.  La  diferencia  m\u00e1s importante entre ambas\n                      sem\u00e1nticas es qu\u00e9 ocurre cuando un dispositivo utilizado para lectura  se  cierra:  en  la\n                      sem\u00e1ntica  SYSV la cinta se avanza hasta pasar la siguiente marca de fichero si esto no ha\n                      ocurrido ya al usar el dispositivo. En la sem\u00e1ntica BSD la posici\u00f3n de la cinta no cambia.\n               EJEMPLO\n                      struct mtop mt_cmd;\n                      mt_cmd.mt_op = MTSETDRVBUFFER;\n                      mt_cmd.mt_count = MT_ST_BOOLEANS |\n                                 MT_ST_BUFFER_WRITES |\n                                 MT_ST_ASYNC_WRITES;\n                      ioctl(fd, MTIOCTOP, &mt_cmd);\n\n               El tama\u00f1o de bloque por defecto para un dispositivo se puede configurar con  MT_ST_DEF_BLKSIZE  y\n               el  c\u00f3digo de densidad por defecto se puede configurar con MT_ST_DEFDENSITY. Los valores para los\n               par\u00e1metros se operan con un O l\u00f3gico con el c\u00f3digo de operaci\u00f3n.\n\n               Con los n\u00facleos 2.1.x y posteriores, los valores de los plazos  de  tiempo  (timeout)  se  pueden\n               configurar  con  la  suborden MT_ST_SET_TIMEOUT operado con un O l\u00f3gico con el plazo de tiempo en\n               segundos.  El plazo largo de tiempo (usado para los rebobinados y otras \u00f3rdenes que pueden tardar\n               mucho  tiempo) se puede configurar con MT_ST_SET_LONG_TIMEOUT. Los valores por defecto del n\u00facleo\n               son muy grandes para asegurarse de que una \u00f3rden exitosa no ser\u00e1 cancelada para  ninguna  unidad.\n               Debido a esto, el manejador puede parecer atascado aun cuando s\u00f3lo est\u00e9 esperando a que se cumpla\n               el plazo de tiempo. Estas \u00f3rdenes se pueden usar para configurar  m\u00e1s  valores  \u00fatiles  para  una\n               unidad  espec\u00edfica.  Los  plazos de tiempo configurados para un dispostivo se aplican a todos los\n               dispositivos ligados a la misma unidad.\n\n   MTIOCGET - Obtiene el estado\n       Esta petici\u00f3n toma un argumento de tipo (struct mtget *).\n\n       /* estructura para MTIOCGET - orden estado de cinta mag */\n       struct mtget {\n           long   mt_type;\n           long   mt_resid;\n           /* los ss. registros son dependientes del dispositivo */\n           long   mt_dsreg;\n           long   mt_gstat;\n           long   mt_erreg;\n           /* Los ss. 2 campos no se usan siempre */\n           daddr_t          mt_fileno;\n           daddr_t          mt_blkno;\n       };\n\n       mt_type    El fichero de cabecera define muchos valores para mt_type, pero el  manejador  actual  informa\n                  s\u00f3lo  de  los  tipos gen\u00e9ricos MT_ISSCSI1 (cinta gen\u00e9rica SCSI-1) y MT_ISSCSI2 (cinta gen\u00e9rica\n                  SCSI-2).\n       mt_resid   contiene el n\u00famero de partici\u00f3n actual de la cinta.\n       mt_dsreg   informa de los valores actuales de la unidad para el tama\u00f1o de bloque  (en  los  24  bits  m\u00e1s\n                  bajos)  y  para  la  densidad  (en  los  8  bits m\u00e1s altos).  Estos campos est\u00e1n definidos por\n                  MT_ST_BLKSIZE_SHIFT, MT_ST_BLKSIZE_MASK, MT_ST_DENSITY_SHIFT, y MT_ST_DENSITY_MASK.\n       mt_gstat   da informaci\u00f3n de estado gen\u00e9rica (independiente del dispositivo).   El  fichero  de  cabecera\n                  define macros para comprobar estos bits de estado:\n                  GMT_EOF(x):  La cinta est\u00e1 posicionada justo tras una marca de fichero (siempre falso tras una\n                      operaci\u00f3n MTSEEK).\n                  GMT_BOT(x): La cinta est\u00e1 posicionada al principio del primer fichero (siempre falso tras  una\n                      operaci\u00f3n MTSEEK).\n                  GMT_EOT(x): Una operaci\u00f3n de cinta ha alcanzado el Final de Cinta f\u00edsico.\n                  GMT_SM(x):  La cinta est\u00e1 posicionada actualmente en una marca de conjunto (siempre falso tras\n                      una operaci\u00f3n MTSEEK).\n                  GMT_EOD(x): La cinta est\u00e1 posicionada al final de datos grabados.\n                  GMT_WR_PROT(x): La unidad est\u00e1 protegida de escritura.  Para  algunas  unidades  esto  tambi\u00e9n\n                      puede significar que no admite escribir en el tipo de medio f\u00edsico actual.\n                  GMT_ONLINE(x):  El  \u00faltimo  open()  encontr\u00f3  a la unidad con una cinta puesta y lista para la\n                      operaci\u00f3n.\n                  GMT_D_6250(x), GMT_D_1600(x), GMT_D_800(x): Esta informaci\u00f3n de estado \u201cgen\u00e9rica\u201d  informa  de\n                      la densidad actual para unidades de cinta de 9 pistas y \u00bd in. solamente.\n                  GMT_DR_OPEN(x): La unidad no tiene una cinta puesta.\n                  GMT_IM_REP_EN(x): Modo de informe inmediato. Este bit se activa si no hay garant\u00edas de que los\n                      datos se hayan escrito f\u00edsicamente en la cinta cuando la llamada de escritura termina.  Se\n                      le asigna el valor cero s\u00f3lo cuando el manejador no usa buffers para los datos y la unidad\n                      no est\u00e1 configurada para usar buffers de datos.\n       mt_erreg   El \u00fanico campo definido en mt_erreg es el n\u00famero de errores recuperados en los 16 bits de  m\u00e1s\n                  bajo   orden  (como  se  define  por  MT_ST_SOFTERR_SHIFT  y  MT_ST_SOFTERR_MASK).   Debido  a\n                  inconsistencias en la forma en que las unidades informan de errores recuperados, este n\u00famero a\n                  menudo  no es mantenido (la mayor\u00eda de las unidades no informan, por defecto, de errores leves\n                  pero esto se puede cambiar con una orden SCSI MODE SELECT).\n       mt_fileno  devuelve el n\u00famero de fichero actual (empezando por cero).  Este valor se pone a -1 cuando  el\n                  n\u00famero de fichero se desconoce (p. ej. despu\u00e9s de MTBSS o MTSEEK).\n       mt_blkno   da  el  n\u00famero de bloque (empezando por cero) dentro del fichero actual.  Este valor se pone a\n                  -1 cuando el n\u00famero de bloque se desconoce (p. ej. despu\u00e9s de MTBSF, MTBSS, o MTSEEK).\n\n   MTIOCPOS - Obtener la posici\u00f3n en la cinta\n       Esta petici\u00f3n toma un argumento de tipo (struct mtpos *) y devuelve la noci\u00f3n que tiene el manejador  del\n       n\u00famero  de  bloque  de  cinta actual, que no es el mismo que mt_blkno devuelto por MTIOCGET.  Esta unidad\n       debe ser de tipo SCSI-2 y debe admitir la orden READ POSITION (direcci\u00f3n espec\u00edfica  del  dispositivo)  o\n       una unidad SCSI-1 compatible Tandberg (Tandberg, Archive Viper, Wangtek, ... ).\n\n       /* estructura para MTIOCPOS - orden obtener posici\u00f3n cinta mag. */\n       struct     mtpos {\n           long   mt_blkno; /* n\u00famero de bloque en curso */\n       };\n\nVALOR DEVUELTO\n       EIO           La operaci\u00f3n pedida no ha podido completarse.\n\n       ENOSPC        Una  operaci\u00f3n de escritura no pudo completarse porque la cinta lleg\u00f3 al final del material\n                     magn\u00e9tico.\n\n       EACCES        Se intent\u00f3 escribir o borrar una cinta protegida para escritura.  (Este error no se detecta\n                     durante open().)\n\n       EFAULT        Los par\u00e1metros de la orden apuntan a memoria que no pertenece al proceso invocador.\n\n       ENXIO         Durante la apertura, el dispositivo de cinta no existe.\n\n       EBUSY         El dispositivo ya est\u00e1 en uso o el manejador ha sido incapaz de reservar un b\u00fafer.\n\n       EOVERFLOW     Se  ha  intentado  leer o escribir un bloque de longitud variable que es mayor que el b\u00fafer\n                     interno del manejador.\n\n       EINVAL        Una llamada a ioctl() ten\u00eda un argumento incorrecto, o  un  tama\u00f1o  de  bloque  pedido  era\n                     ilegal.\n\n       ENOSYS        ioctl() desconocido.\n\n       EROFS         Se  ha  intentado realizar una operaci\u00f3n `open' con O_WRONLY o O_RDWR cuando la cinta de la\n                     unidad est\u00e1 protegida contra escritura.\n\n", "FICHEROS": "       /dev/st*  : dispositivos de cinta SCSI con autorebobinado\n       /dev/nst* : dispositivos de cinta SCSI sin rebobinado\n\n", "AUTOR": "       El manejador ha sido escrito por by Kai M\u00e4kisara (Kai.Makisara@metla.fi) a partir del  manejador  escrito\n       por Dwayne Forsyth. Varias otras personas tambi\u00e9n han contribuido al manejador.\n\nV\u00c9ASE TAMBI\u00c9N\n       mt(1)\n\n       El  fichero  README.st de los fuentes del n\u00facleo contiene la informaci\u00f3n m\u00e1s reciente del manejador y sus\n       posibilidades de configuraci\u00f3n.\n\n", "OBSERVACIONES": "       1. Cuando se intercambian datos entre sistemas, ambos sistemas deben coincidir en el  tama\u00f1o  f\u00edsico  del\n       bloque  de la cinta. Los par\u00e1metros de una unidad despu\u00e9s del arranque no son, con frecuencia, los que la\n       mayor\u00eda de los sistemas operativos usan con estos dispositivos. La mayor\u00eda de los sistemas usan  unidades\n       en  modo de bloque variable si la unidad soporta ese modo. Esto es aplicable a la mayor\u00eda de las unidades\n       modernas, incluyendo DATs, unidades de recorrido helicoidal de 8mm, DLTs, etc. Puede ser aconsejable usar\n       estas unidades en modo variable tambi\u00e9n en Linux (es decir, use MTSETBLK o MTSETDEFBLK en el arranque del\n       sistema para establecer el modo), al menos  cuando  se  intercambien  datos  con  sistemas  externos.  El\n       inconveniente  de esto es que se debe usar un tama\u00f1o de bloque de cinta bastante largo para obtener tasas\n       de transferencia de datos aceptables sobre el bus SCSI.  2. Muchos programas (por ejemplo, tar)  permiten\n       al  usuario  especificar  el  tama\u00f1o  de bloque en la l\u00ednea de \u00f3rdenes. Dese cuenta que esto determina el\n       tama\u00f1o f\u00edsico del bloque en la cinta s\u00f3lo en el modo de bloque variable.\n\n       3. Para usar unidades de cinta SCSI, el manejador b\u00e1sico de SCSI, el manejador de un adaptador SCSI y  el\n       manejador  de  cintas SCSI deben estar bien configurados dentro del n\u00facleo o cargados como m\u00f3dulos. Si el\n       manejador de cintas SCSI no est\u00e1 presente, se reconoce la unidad pero el soporte  de  cinta  descrito  en\n       esta p\u00e1gina no est\u00e1 disponible.\n\n       4.  El manejador escribe los mensajes de error a la consola/registro(log).  Los c\u00f3digos SENSE escritos en\n       algunos mensajes se traducen autom\u00e1tica a texto si se han habilitado en la configuraci\u00f3n del  n\u00facleo  los\n       mensajes SCSI prolijos.\n\n", "COPYRIGHT": "       Copyright \u00a9 1995 Robert K. Nichols.\n       Copyright \u00a9 1999 Kai M\u00e4kisara.\n\n       Se da permiso para hacer y distribuir copias id\u00e9nticas de este manual supuesto que la nota de copyright y\n       \u00e9sta de permiso se preservan en todas las copias.  El fichero de  cabecera  del  c\u00f3digo  fuente  contiene\n       permisos adicionales.\n\nLinux 2.0 - 2.2                                   18 enero 1999                                            ST(4)\n"},{"NOMBRE": "       tty - imprime el nombre del fichero del terminal conectado a la entrada est\u00e1ndar\n\n", "SINOPSIS": "       tty [-s] [--silent] [--quiet] [--help] [--version]\n\n", "DESCRIPCI\u00d3N": "       Esta  documentaci\u00f3n  no  va  a  ser  mantenida  a  partir  de ahora y puede ser inexacta o incompleta. La\n       documentaci\u00f3n Texinfo es ahora la fuente autorizada.\n\n       Esta p\u00e1gina de manual documenta la versi\u00f3n de GNU de tty.  tty imprime el  nombre  del  fichero  del  tty\n       conectado a su entrada est\u00e1ndar.  Imprime `not a tty' si la entrada est\u00e1ndar no es una tty. Acaba con los\n       siguientes valores:\n       0 si la entrada est\u00e1ndar es una tty\n       1 si la entrada est\u00e1ndar no es una tty\n       2 si se le dieron argumentos incorrectos\n       3 si ocurrieron errores de escritura\n\n   OPCIONES\n       --help Imprime un mensaje del uso por la salida est\u00e1ndar y termina satisfactoriamente.\n\n       -s, --silent, --quiet\n              No imprime nada; solo retorna un valor de terminaci\u00f3n correcta.\n\n       --version\n              Imprime informaci\u00f3n sobre la versi\u00f3n por la salida est\u00e1ndar y termina satisfactoriamente.\n\nFSF                                          Utilidades Shell de GNU                                      TTY(1)\n"},{"NOMBRE": "       tty ioctl - ioctls para terminales y l\u00edneas serie\n\n", "SINOPSIS": "       #include <termios.h>\n\n       int ioctl(int fd, int cmd, ...);\n\n", "DESCRIPCI\u00d3N": "       La llamada ioctl() para terminales y puertos serie acepta muchas \u00f3rdenes que se pasan como argumentos. La\n       mayor\u00eda necesita un tercer argumento, de tipo variable, que aqu\u00ed llamamos argp o arg.\n\n       El uso de ioctl hace que un programa no sea (trans)portable. Use la interfaz POSIX descrita en termios(3)\n       siempre que sea posible.\n\n   Obtener y establecer los atributos de un terminal\n       TCGETS    struct termios *argp\n              Equivalente a tcgetattr(fd, argp).\n              Obtiene la configuraci\u00f3n actual de un puerto serie.\n\n       TCSETS    const struct termios *argp\n              Equivalente a tcsetattr(fd, TCSANOW, argp).\n              Establece la configuraci\u00f3n actual de un puerto serie.\n\n       TCSETSW   const struct termios *argp\n              Equivalente a tcsetattr(fd, TCSADRAIN, argp).\n              Permite vaciar el buffer de salida y establecer la configuraci\u00f3n actual de un puerto serie.\n\n       TCSETSF   const struct termios *argp\n              Equivalente a tcsetattr(fd, TCSAFLUSH, argp).\n              Permite  vaciar  el buffer de salida, descartar la entrada pendiente y establecer la configuraci\u00f3n\n              actual de un puerto serie.\n\n       Las siguientes cuatro ioctls son exactamente iguales a TCGETS, TCSETS, TCSETSW y TCSETSF, excepto en  que\n       toman un argumento struct termio * en lugar de un argumento struct termios *.\n\n       TCGETA    struct termio *argp\n\n       TCSETA    const struct termio *argp\n\n       TCSETAW   const struct termio *argp\n\n       TCSETAF   const struct termio *argp\n\n   Bloqueo de una estructura termios\n       La estructura termios de un tty se puede bloquear. El propio bloqueo es una estructura termios con bits o\n       campos distintos de cero indicando un valor bloqueado.\n\n       TIOCGLCKTRMIOS struct termios *argp\n              Obtiene el estado de bloqueo de la estructura termios del terminal.\n\n       TIOCSLCKTRMIOS const struct termios *argp\n              Establece el estado de bloqueo de la estructura termios del terminal. S\u00f3lo el  superusuario  puede\n              hacer esto.\n\n   Obtener y establecer el tama\u00f1o de la ventana\n       Los  tama\u00f1os  de  las  ventanas  se  guardan en el n\u00facleo pero \u00e9ste no los usa (excepto en el caso de las\n       consolas virtuales, donde el n\u00facleo actualizar\u00e1 el tama\u00f1o de la ventana cuando el tama\u00f1o  de  la  consola\n       virtual cambie, por ejemplo, al cargar una nueva fuente).\n\n       TIOCGWINSZ     struct winsize *argp\n              Obtiene el tama\u00f1o de la ventana.\n\n       TIOCSWINSZ     const struct winsize *argp\n              Establece el tama\u00f1o de la ventana.\n\n       La estructura usada por estas ioctls se define como\n\n       struct winsize {\n               unsigned short ws_row;\n               unsigned short ws_col;\n               unsigned short ws_xpixel;   /* sin usar */\n               unsigned short ws_ypixel;   /* sin usar */\n       };\n\n       Cuando el tama\u00f1o de la ventana cambia, se env\u00eda una se\u00f1al SIGWINCH al grupo de procesos en primer plano.\n\n   Env\u00edo de una pausa (break)\n       TCSBRK    int arg\n              Equivalente a tcsendbreak(fd, arg).\n              Si la termina usa una transmisi\u00f3n as\u00edncrona serie de datos y si el argumento arg es cero, entonces\n              env\u00eda una pausa (un flujo de bits a cero) con una duraci\u00f3n de entre 0'25 y  0'5  segundos.  Si  el\n              terminal  no  usa  una  transmisi\u00f3n  as\u00edncrona  serie de datos, entonces o se env\u00eda una pausa o la\n              funci\u00f3n regresa sin hacer nada.  Cuando arg no es cero, nadie sabe qu\u00e9 ocurrir\u00e1.\n\n              (SVR4, UnixWare, Solaris y Linux tratan tcsendbreak(fd,arg) como tcdrain(fd) cuando  el  argumento\n              arg  es distinto de cero. SunOS trata arg como un multiplicador y env\u00eda arg veces un flujo de bits\n              tan largo como el que se env\u00eda para un valor de arg igual a  cero.   DG-UX  y  AIX  tratan  a  arg\n              (cuando no es cero) como un intervalo de tiempo medido en milisegundos.  HP-UX ignora arg.)\n\n       TCSBRKP   int arg\n              Conocida  como  la  \"versi\u00f3n  POSIX\" de TCSBRK. Trata un arg distinto de cero como un intervalo de\n              tiempo medido en d\u00e9cimas de segundo y no hace nada cuando el driver no soporta pausas.\n\n       TIOCSBRK  void\n              Activa la pausa, es decir, empieza a enviar bits a cero.\n\n       TIOCCBRK  void\n              Desactiva la pausa, es decir, deja de enviar bits a cero.\n\n   Control de flujo software\n       TCXONC    int arg\n              Equivalente a tcflow(fd, arg).\n              Vea tcflow(3) para los valores de argumento TCOOFF, TCOON, TCIOFF y TCION.\n\n   Escrutinio y vaciado de buffers\n       FIONREAD  int *argp\n              Obtiene el n\u00famero de bytes en el buffer de entrada.\n\n       TIOCINQ   int *argp\n              Igual que FIONREAD.\n\n       TIOCOUTQ  int *argp\n              Obtienen el n\u00famero de bytes en el buffer de salida.\n\n       TCFLSH    int arg\n              Equivalente a tcflush(fd, arg).\n              Vea tcflush(3) para los valores de argumento TCIFLUSH, TCOFLUSH y TCIOFLUSH.\n\n   Falsificaci\u00f3n de la entrada\n       TIOCSTI   const char *argp\n              Inserta el byte dado en la cola de entrada.\n\n   Redirecci\u00f3n de la salida de consola\n       TIOCCONS  void\n              Redirecciona la salida que habr\u00eda ido a /dev/console o /dev/tty0 al tty dado. Si \u00e9ste  es  un  pty\n              maestro,  env\u00eda  la  salida  a la parte esclava. Cualquier usuario puede hacer esto siempre que la\n              salida no haya sido ya redireccionada. Si ya fue  redireccionada,  se  devuelve  el  valor  EBUSY,\n              aunque  el  root  puede detener la redirecci\u00f3n usando esta ioctl con fd apuntando a /dev/console o\n              /dev/tty0.\n\n   tty controlador\n       TIOCSCTTY int arg\n              Convierte al tty dado en el tty controlador del proceso actual. El  proceso  actual  debe  ser  un\n              l\u00edder de sesi\u00f3n y no tener ya un tty controlador. Si este tty es ya el tty controlador de un grupo\n              de sesi\u00f3n diferente entonces la llamada a ioctl falla con EPERM, a menos que el invocador  sea  el\n              root  y  arg  valga  1,  en cuyo caso se `roba' el tty y todos los procesos que lo ten\u00edan como tty\n              controlador lo pierden.\n\n       TIOCNOTTY void\n              Si el tty dado fuera el tty controlador del proceso actual, se abandona este tty  controlador.  Si\n              el  proceso  fuera  el l\u00edder de sesi\u00f3n, entonces se env\u00eda SIGHUP y SIGCONT al grupo de procesos en\n              primer plano y todos los procesos en la sesi\u00f3n actual pierden sus ttys controladores.\n\n   (N\u00famero) identificador (ID) de grupo de procesos y sesi\u00f3n\n       TIOCGPGRP pid_t *argp\n              Cuando tiene \u00e9xito, equivale a *argp = tcgetpgrp(fd).\n              Obtiene el ID del grupo de procesos en primer plano en este tty.\n\n       TIOCSPGRP const pid_t *argp\n              Equivalente a tcsetpgrp(fd, *argp).\n              Establece el ID del grupo de procesos en primer plano de este tty.\n\n       TIOCGSID  pid_t *argp\n              Obtiene el ID de sesi\u00f3n del tty dado. La llamada fallar\u00e1 con ENOTTY en el caso en el que el tty no\n              sea un pty maestro ni nuestro tty controlador. Raro.\n\n   Modo exclusivo\n       TIOCEXCL  void\n              Coloca  el tty en modo exclusivo.  No se permiten m\u00e1s operaciones open(2) sobre el terminal (\u00e9stas\n              fallar\u00e1n con EBUSY excepto para el root).\n\n       TIOCNXCL  void\n              Desactiva el modo exclusivo.\n\n   Disciplina de l\u00ednea\n       TIOCGETD  int *argp\n              Obtiene la disciplina de l\u00ednea del tty.\n\n       TIOCSETD  const int *argp\n              Establece la disciplina de l\u00ednea del tty.\n\n   Ioctls de los pseudo-tty\n       TIOCPKT   const int *argp\n              Activa (cuando *argp no es cero) o desactiva el modo de paquetes. S\u00f3lo se puede aplicar a la parte\n              maestra  de un pseudo-tty (y devolver\u00e1 ENOTTY en otro caso).  En el modo de paquetes, cada read(2)\n              posterior devolver\u00e1 un paquete que contiene o bien un \u00fanico byte de control  distinto  de  cero  o\n              bien un \u00fanico byte a 0 seguido de datos escritos en la parte esclava del pty. Si el primer byte no\n              es TIOCPKT_DATA (0), entonces es un O-l\u00f3gico de uno o m\u00e1s de los siguientes bits:\n\n              TIOCPKT_FLUSHREAD   La cola de lectura del terminal est\u00e1 vac\u00eda.\n              TIOCPKT_FLUSHWRITE  La cola de escritura del terminal est\u00e1 vac\u00eda.\n              TIOCPKT_STOP        Se para la salida del terminal.\n              TIOCPKT_START       Se reinicia la salida del terminal.\n              TIOCPKT_DOSTOP      t_stopc es `^S' y t_startc es `^Q'.\n              TIOCPKT_NOSTOP      los caracteres de inicio y parada no son `^S/^Q'.\n\n              Mientras se use este modo, se puede detectar la presencia de datos de entrada en la parte  maestra\n              del pty mediante una llamada a select(2).  Dichos datos contienen informaci\u00f3n de estado de control\n              para condiciones excepcionales.\n\n              Este modo lo usan rlogin(1) y rlogind(8) para implementar un login remoto con un flujo  controlado\n              localmente mediante `^S/^Q' y un eco remoto.\n\n              Las ioctls de BSD TIOCSTOP, TIOCSTART, TIOCUCNTL, TIOCREMOTE no se han implementado en Linux.\n\n   Control del modem\n       TIOCMGET  int *argp\n              Obtiene el estado de los bits del modem.\n\n       TIOCMSET  const int *argp\n              Configura el estado de los bits del modem.\n\n       TIOCMBIC  const int *argp\n              Borra los bits del modem que se indican.\n\n       TIOCMBIS  const int *argp\n              Activa los bits del modem que se indican.\n\n       Los bits usados para estas cuatro ioctls son:\n\n       TIOCM_LE        DSR (data set ready/line enable)\n       TIOCM_DTR       DTR (data terminal ready)\n       TIOCM_RTS       RTS (request to send)\n       TIOCM_ST        TXD secundario (transmitir)\n       TIOCM_SR        RXD secundario (recibir)\n       TIOCM_CTS       CTS (clear to send)\n       TIOCM_CAR       DCD (data carrier detect)\n       TIOCM_CD         vea TIOCM_CAR\n       TIOCM_RNG       RNG (ring)\n       TIOCM_RI         vea TIOCM_RNG\n       TIOCM_DSR       DSR (data set ready)\n\n   Marcar una l\u00ednea como local\n       TIOCGSOFTCAR   int *argp\n              (\"Get  software  carrier  flag\")  Obtiene  el  estado de la bandera CLOCAL del campo c_cflag de la\n              estructura termios.\n\n       TIOCSSOFTCAR   const int *argp\n              (\"Set software carrier flag\") Activa la bandera CLOCAL de la estructura termios  cuando  *argp  es\n              distinto de cero y la borra en caso contrario.\n\n       Si la bandera CLOCAL para una l\u00ednea est\u00e1 apagada, la se\u00f1al de detecci\u00f3n de la portadora hardware (DCD) es\n       significativa y una operaci\u00f3n open(2) sobre el tty correspondiente se bloquear\u00e1 hasta que se produzca  el\n       aserto de DCD, a menos que se haya especificado la opci\u00f3n O_NONBLOCK.  Si CLOCAL est\u00e1 activa, la l\u00ednea se\n       comporta como si DCD estuviera siempre activa. Normalmente,  la  bandera  de  la  portadora  software  se\n       enciende para los dispositivos locales y se apaga para las l\u00edneas con modems.\n\n   Espec\u00edfico de Linux\n       Para la ioctl TIOCLINUX vea console_ioctl(4).\n\n   Depuraci\u00f3n del n\u00facleo\n       #include <linux/tty.h>\n\n       TIOCTTYGSTRUCT struct tty_struct *argp\n              Obtiene la tty_struct correspondiente a fd.\n\nVALOR DEVUELTO\n       La  llamada al sistema ioctl() devuelve 0 en caso de \u00e9xito. En caso de error devuelve -1 y asigna a errno\n       un valor adecuado.\n\n", "ERRORES": "       ENOIOCTLCMD\n              Orden desconocida.\n\n       EINVAL Par\u00e1metro de orden inv\u00e1lido.\n\n       EPERM  Permiso insuficiente.\n\n       ENOTTY fd inapropiado.\n\n", "EJEMPLO": "       Comprueba el estado de la l\u00ednea DTR del puerto serie.\n\n       #include <termios.h>\n       #include <fcntl.h>\n       #include <sys/ioctl.h>\n\n       main() {\n           int fd, serial;\n\n           fd = open(\"/dev/ttyS0\", O_RDONLY);\n           ioctl(fd, TIOCMGET, &serial);\n           if (serial & TIOCM_DTR)\n               puts(\"TIOCM_DTR est\u00e1 apagado\");\n           else\n               puts(\"TIOCM_DTR est\u00e1 encendido\");\n           close(fd);\n       }\n\nV\u00c9ASE TAMBI\u00c9N\n       ioctl(2), termios(3), console_ioctl(4).\n\nLinux                                           29 diciembre 2002                                   TTY_IOCTL(4)\n"},{"NOMBRE": "       ttys - l\u00edneas serie de terminales\n\n", "DESCRIPCI\u00d3N": "       ttyS[0-3] son los dispositivos de caracter para las l\u00edneas serie de terminales.\n\n       Normalmente se crean con:\n\n              mknod -m 660 /dev/ttyS0 c 4 64 # dir. base 0x03f8\n              mknod -m 660 /dev/ttyS1 c 4 65 # dir. base 0x02f8\n              mknod -m 660 /dev/ttyS2 c 4 66 # dir. base 0x03e8\n              mknod -m 660 /dev/ttyS3 c 4 67 # dir. base 0x02e8\n              chown root:tty /dev/ttyS[0-3]\n\n", "FICHEROS": "       /dev/ttyS[0-3]\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1), getty(1), tty(4), setserial(8).\n\nLinux                                           19 diciembre 1992                                        TTYS(4)\n"},{"NOMBRE": "       random, urandom - dispositivos de la fuente de n\u00fameros aleatorios del n\u00facleo\n\n", "DESCRIPCI\u00d3N": "       Los  ficheros  especiales  de  caracteres /dev/random y /dev/urandom (presente desde la versi\u00f3n 1.3.30 de\n       Linux) proporcionan una interfaz con  el  generador  de  n\u00fameros  aleatorios  del  n\u00facleo.   El  ficheros\n       /dev/random  tiene  1  como  n\u00famero major de dispositivo y 8 como n\u00famero menor de dispositivo. El fichero\n       /dev/urandom tiene 1 como n\u00famero major de dispositivo y 9 como n\u00famero menor de dispositivo.\n\n       El generador de n\u00fameros aleatorios recoge el ruido ambiental procedente de los manejadores de dispositivo\n       y otras fuentes y lo guarda en un \"almacen de entrop\u00eda\". El generador tambi\u00e9n mantiene una estimaci\u00f3n del\n       n\u00famero de bits de ru\u00eddo en el almacen de entrop\u00eda. Los n\u00fameros aleatorios  se  crean  a  partir  de  este\n       almacen.\n\n       En  las lecturas, el dispositivo /dev/random s\u00f3lo devolver\u00e1 bytes aleatorios teniendo en cuenta el n\u00famero\n       de bits de ru\u00eddo en el almacen de entrop\u00eda  (es  decir,  se  devolver\u00e1n  los  bytes  solicitados  si  hay\n       suficientes bits en el almacen para formar dichos bytes). /dev/random debe ser adecuado en aquellos casos\n       en los que se necesite una aleatoriedad de gran calidad tales como \"one-time  pad\"  y  la  generaci\u00f3n  de\n       claves.  Cuando el almacen de entrop\u00eda est\u00e1 vac\u00edo, las lecturas sobre /dev/random se bloquear\u00e1n hasta que\n       se recoga ruido ambiental adicional.\n\n       En las lecturas, el dispositivo /dev/urandom devolver\u00e1 tantos bytes como se soliciten. Como resultado, si\n       no  hay suficiente entrop\u00eda en el almacen de entrop\u00eda, los valores devueltos son te\u00f3ricamente vulnerables\n       a un ataque criptogr\u00e1fico sobre los algoritmos usados por el manejador. El  conocimiento  de  c\u00f3mo  hacer\n       esto  no  est\u00e1  disponible  en  la literatura \"sin clasificar\" actual pero te\u00f3ricamente es posible que un\n       ataque as\u00ed pueda existir. Si esto es una preocupaci\u00f3n de su aplicaci\u00f3n, use /dev/random en su lugar.\n\n", "CONFIGURACI\u00d3N": "       Si en su sistema no existen todav\u00eda  /dev/random  y  /dev/urandom,  puede  crearlos  con  las  siguientes\n       \u00f3rdenes:\n\n               mknod -m 644 /dev/random c 1 8\n               mknod -m 644 /dev/urandom c 1 9\n               chown root:root /dev/random /dev/urandom\n\n       Cuando  un sistema Linux arranca sin mucha interaci\u00f3n del operador, el almacen de entrop\u00eda puede estar en\n       un estado bastante predecible.  Esto reduce la cantidad actual de ruido en el  almacen  de  entrop\u00eda  por\n       debajo  de lo recomendado. Para contrarestar este efecto, podemos conservar la informaci\u00f3n del almacen de\n       entrop\u00eda entre las paradas y arranques del sistema. Para hacer esto, a\u00f1ada las  siguientes  l\u00edneas  a  un\n       gui\u00f3n shell adecuado que se ejecute durante la secuencia de arranque del sistema Linux:\n\n            echo \"Initializando el generador de n\u00fameros aleatorios del n\u00facleo...\"\n            # Initializamos el generador de n\u00fameros aleatorios del n\u00facleo\n            # de este arranque a partir de la semilla aleatoria de la \u00faltima\n            # parada (o arranque). Cargamos y a continuaci\u00f3n salvamos 512 bytes,\n            # que es el tama\u00f1o del almacen de entrop\u00eda.\n            if [ -f /var/random-seed ]; then\n                 cat /var/random-seed >/dev/urandom\n            fi\n            dd if=/dev/urandom of=/var/random-seed count=1\n\n       Tambi\u00e9n,  a\u00f1ada  las  siguientes  l\u00edneas  a un gui\u00f3n shell apropiado que se ejecute durante la parada del\n       sistema Linux:\n\n            # Mantenemos una semilla aleatoria entre una parada y un arranque\n            # para el generador de n\u00fameros aleatorios. Salvamos 512 bytes, que\n            # es el tama\u00f1o del almacen de entrop\u00eda del generador de n\u00fameros\n            # aleatorios.\n            echo \"Salvando semilla aleatoria...\"\n            dd if=/dev/urandom of=/var/random-seed count=1\n\n", "FICHEROS": "       /dev/random\n       /dev/urandom\n\n", "AUTOR": "       El generador de n\u00fameros aleatorios del n\u00facleo fue escrito por Theodore Ts'o (tytso@athena.mit.edu).\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod (1)\n       RFC 1750, \"Randomness Recommendations for Security\"\n\nLinux                                             1 Agosto 1997                                        RANDOM(4)\n"},{"NOMBRE": "       vcs, vcsa - memoria de la consola virtual\n\n", "DESCRIPCI\u00d3N": "       /dev/vcs0  es un dispositivo de car\u00e1cter con n\u00famero mayor 7 y n\u00famero menor 0, creado normalmente con modo\n       0644 y propietario root.tty. Designa la memoria del  terminal  de  consola  virtual  visualizado  en  ese\n       momento.\n\n       /dev/vcs[1-63]  son los dispositivos de car\u00e1cter para los terminales de consola virtual. Tienen el n\u00famero\n       mayor 7 y el n\u00famero menor de 1 a 63, y se crean normalmente con el  modo  0644  y  propietario  root.tty.\n       /dev/vcsa[0-63]  son  lo  mismo, pero incluyendo los atributos, y prefijados con cuatro bytes que indican\n       las dimensiones de la pantalla y la posici\u00f3n del cursor: l\u00edneas, columnas, x, y (x = y = 0 en la  esquina\n       superior izquierda de la pantalla).\n\n       Estos  dispositivos  reemplazan  las  ioctls  de  volcado  de  pantalla  de  console(4),  de forma que el\n       administrador del sistema pueda controlar el acceso a trav\u00e9s de los permisos del sistema de ficheros.\n\n       Los dispositivos de las ocho primeras consolas virtuales se pueden crear con:\n\n            for x in 0 1 2 3 4 5 6 7 8; do\n                 mknod -m 644 /dev/vcs$x c 7 $x;\n                 mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\n            done\n            chown root:tty /dev/vcs*\n\n       No se aceptan peticiones de ioctl().\n\n", "EJEMPLOS": "       Se puede hacer un volcado de pantalla de vt3 conmutando a vt1 y tecleando cat /dev/vcs3 >foo. N\u00f3tese  que\n       la  salida  no  contiene  caracteres de nueva l\u00ednea, por lo que puede ser necesario algo de procesamiento\n       adicional, como por ejemplo en fold  -w  81  /dev/vcs3  |  lpr  o  en  (horror)  setterm  -dump  3  -file\n       /proc/self/fd/1.\n\n       El dispositivo /dev/vcsa0 se utiliza para el soporte Braille.\n\n       El siguiente programa visualiza los atributos de car\u00e1cter y pantalla que se encuentran en la posici\u00f3n del\n       cursor de la segunda consola virtual, y despu\u00e9s cambia su color de fondo all\u00ed:\n\n            #include <unistd.h>\n            #include <stdlib.h>\n            #include <stdio.h>\n            #include <fcntl.h>\n\n            int main() {\n                 int fd;\n                 char *device = \"/dev/vcsa2\";\n                 struct {unsigned char lines, cols, x, y;} scrn;\n                 char ch, attrib;\n\n                 fd = open(device, O_RDWR);\n                 if (fd < 0) {\n                      perror(device);\n                      exit(1);\n                 }\n                 (void)read(fd, &scrn, 4);\n                 (void)lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), 0);\n                 (void)read(fd, &ch, 1);\n                 (void)read(fd, &attrib, 1);\n                 printf(\"ch='%c' attrib=0x%02x\\n\", ch, attrib);\n                 attrib ^= 0x10;\n                 (void)lseek(fd, -1, 1);\n                 (void)write(fd, &attrib, 1);\n                 return 0;\n            }\n\n", "FICHEROS": "       /dev/vcs[0-63]\n       /dev/vcsa[0-63]\n\n", "AUTOR": "       Andries Brouwer <aeb@cwi.nl>\n\n", "HISTORIA": "       Disponible a partir de la versi\u00f3n 1.1.92 del n\u00facleo de Linux.\n\nV\u00c9ASE TAMBI\u00c9N\n       console(4), tty(4), ttys(4), selection(1)\n\nLinux                                             2 Julio 1996                                            VCS(4)\n"},{"NOMBRE": "       vcs, vcsa - memoria de la consola virtual\n\n", "DESCRIPCI\u00d3N": "       /dev/vcs0  es un dispositivo de car\u00e1cter con n\u00famero mayor 7 y n\u00famero menor 0, creado normalmente con modo\n       0644 y propietario root.tty. Designa la memoria del  terminal  de  consola  virtual  visualizado  en  ese\n       momento.\n\n       /dev/vcs[1-63]  son los dispositivos de car\u00e1cter para los terminales de consola virtual. Tienen el n\u00famero\n       mayor 7 y el n\u00famero menor de 1 a 63, y se crean normalmente con el  modo  0644  y  propietario  root.tty.\n       /dev/vcsa[0-63]  son  lo  mismo, pero incluyendo los atributos, y prefijados con cuatro bytes que indican\n       las dimensiones de la pantalla y la posici\u00f3n del cursor: l\u00edneas, columnas, x, y (x = y = 0 en la  esquina\n       superior izquierda de la pantalla).\n\n       Estos  dispositivos  reemplazan  las  ioctls  de  volcado  de  pantalla  de  console(4),  de forma que el\n       administrador del sistema pueda controlar el acceso a trav\u00e9s de los permisos del sistema de ficheros.\n\n       Los dispositivos de las ocho primeras consolas virtuales se pueden crear con:\n\n            for x in 0 1 2 3 4 5 6 7 8; do\n                 mknod -m 644 /dev/vcs$x c 7 $x;\n                 mknod -m 644 /dev/vcsa$x c 7 $[$x+128];\n            done\n            chown root:tty /dev/vcs*\n\n       No se aceptan peticiones de ioctl().\n\n", "EJEMPLOS": "       Se puede hacer un volcado de pantalla de vt3 conmutando a vt1 y tecleando cat /dev/vcs3 >foo. N\u00f3tese  que\n       la  salida  no  contiene  caracteres de nueva l\u00ednea, por lo que puede ser necesario algo de procesamiento\n       adicional, como por ejemplo en fold  -w  81  /dev/vcs3  |  lpr  o  en  (horror)  setterm  -dump  3  -file\n       /proc/self/fd/1.\n\n       El dispositivo /dev/vcsa0 se utiliza para el soporte Braille.\n\n       El siguiente programa visualiza los atributos de car\u00e1cter y pantalla que se encuentran en la posici\u00f3n del\n       cursor de la segunda consola virtual, y despu\u00e9s cambia su color de fondo all\u00ed:\n\n            #include <unistd.h>\n            #include <stdlib.h>\n            #include <stdio.h>\n            #include <fcntl.h>\n\n            int main() {\n                 int fd;\n                 char *device = \"/dev/vcsa2\";\n                 struct {unsigned char lines, cols, x, y;} scrn;\n                 char ch, attrib;\n\n                 fd = open(device, O_RDWR);\n                 if (fd < 0) {\n                      perror(device);\n                      exit(1);\n                 }\n                 (void)read(fd, &scrn, 4);\n                 (void)lseek(fd, 4 + 2*(scrn.y*scrn.cols + scrn.x), 0);\n                 (void)read(fd, &ch, 1);\n                 (void)read(fd, &attrib, 1);\n                 printf(\"ch='%c' attrib=0x%02x\\n\", ch, attrib);\n                 attrib ^= 0x10;\n                 (void)lseek(fd, -1, 1);\n                 (void)write(fd, &attrib, 1);\n                 return 0;\n            }\n\n", "FICHEROS": "       /dev/vcs[0-63]\n       /dev/vcsa[0-63]\n\n", "AUTOR": "       Andries Brouwer <aeb@cwi.nl>\n\n", "HISTORIA": "       Disponible a partir de la versi\u00f3n 1.1.92 del n\u00facleo de Linux.\n\nV\u00c9ASE TAMBI\u00c9N\n       console(4), tty(4), ttys(4), selection(1)\n\nLinux                                             2 Julio 1996                                            VCS(4)\n"},{"NOMBRE": "       wavelan - controlador del dispositivo AT&T GIS WaveLAN ISA\n\n", "SINOPSIS": "       insmod wavelan_cs.o [io=B,B..] [ irq=I,I..] [name=N,N..]\n\n", "DESCRIPCI\u00d3N": "       wavelan es el controlador de dispositivo de bajo nivel para el adaptador Ethernet inal\u00e1mbrico WaveLAN ISA\n       de NCR / AT&T / Lucent y RoamAbout DS de Digital (DEC).  Este controlador est\u00e1 disponible como  m\u00f3dulo  o\n       puede compilarse en el n\u00facleo. Este controlador admite varias tarjetas en ambas formas (hasta 4) y asigna\n       el siguiente controlador Ethernet disponible (eth0..eth#) para cada tarjeta que encuentra, a menos que se\n       especifique  expl\u00edcitamente  un  nombre  de  dispositivo (vea m\u00e1s abajo). Este nombre de dispositivo ser\u00e1\n       registrado en el fichero de registro del n\u00facleo con la direcci\u00f3n f\u00edsica (MAC), NWID y frecuencia empleada\n       por la tarjeta.\n\n", "PAR\u00c1METROS": "       Esta  secci\u00f3n  se  aplica  al  m\u00f3dulo  (par\u00e1metros  pasados  en  la  l\u00ednea de orden de insmod(8)).  Si el\n       controlador se incluye en el n\u00facleo, emplee la sintaxis ether=IRQ,IO,NAME en  la  l\u00ednea  de  \u00f3rdenes  del\n       n\u00facleo.\n\n       io     Especifica  la  lista de direcciones de base donde buscar tarjetas Wavelan (se establece por medio\n              de un interruptor en la tarjeta). Si  no  se  especifica  ninguna  direcci\u00f3n  io,  el  controlador\n              rastrear\u00e1 las direcciones 0x390 y 0x3E0, que pueden entrar en conflicto con otro hardware...\n\n       irq    Establece  la  lista de interrupciones (IRQ) que cada tarjeta Wavelan podr\u00eda utilizar (el valor se\n              guarda en almacenamiento permanente para un uso futuro).\n\n       name   Establece la lista de nombres que ser\u00e1n empleados para cada dispositivo tarjeta  Wavelan  (nombres\n              empleados por ifconfig(8)).\n\nEXTENSIONES INAL\u00c1MBRICAS\n       Emplee iwconfig(8) para manipular extensiones inal\u00e1mbricas.\n\n   NWID (o dominio)\n       Establece  la  ID  de  red  [0  a  FFFF]  o  la inhabilita [off].  Como el NWID se almacena en el \u00c1rea de\n       Almacenamiento Permanente de la tarjeta, ser\u00e1 reutilizado en cualquier llamada posterior del controlador.\n\n   Frecuencia y canales\n       Para el hardware 2.00 a 2,4 GHz, Ud. puede establecer la frecuencia especificando uno de los  10  canales\n       definidos  (2.412,  2.422,  2.425,  2.4305,  2.432, 2.442, 2.452, 2.460, 2.462 o 2.484) o directamente su\n       valor. La frecuencia se cambia inmediata y permanentemente. La disponibilidad de la frecuencia depende de\n       los reglamentos y regulaciones...\n\n   Estad\u00edsticas de esp\u00eda\n       Establece una lista de direcciones Ethernet (MAC) en el dispositivo (hasta 8) y obtiene la \u00faltima calidad\n       de enlace para cada una de ellas (vea iwspy(8)).\n\n   /proc/net/wireless\n       status es el estado seg\u00fan informa el m\u00f3dem.  Calidad de enlace informa de la calidad de la modulaci\u00f3n  en\n       el  aire  (espectro  extendido  de  secuencia directa) [max = 16].  Level y Noise se refieren al nivel de\n       se\u00f1al y nivel de ruido [max = 64 ].  Los contadores crypt discarded packet y  misc  discarded  packet  no\n       est\u00e1n implementados.\n\nIOCTL PRIVADO\n       Ud. puede utilizar iwpriv(8) para manipular ioctls privadas.\n\n   Umbral de Calidad y Nivel\n       Le permite definir el umbral de calidad y nivel empleado por el m\u00f3dem (un paquete por debajo de ese nivel\n       es descartado).\n\n   Histograma\n       Esta funcionalidad permite establecer un n\u00famero de intervalos de nivel de se\u00f1al y  contar  el  n\u00famero  de\n       paquetes  recibidos  en  cada  uno de estos intervalos definidos. Esta distribuci\u00f3n podr\u00eda emplearse para\n       calcular el valor medio y la desviaci\u00f3n est\u00e1ndar del nivel de se\u00f1al.\n\nOBSERVACIONES ESPEC\u00cdFICAS\n       Este controlador fallar\u00e1 en la detecci\u00f3n de algunas tarjetas Wavelan no de NCR/ATT&T/Lucent.  Si \u00e9ste  es\n       su caso, Ud. debe mirar en el c\u00f3digo fuente c\u00f3mo a\u00f1adir su tarjeta en la rutina de detecci\u00f3n.\n\n       Algunas  de  las  caracter\u00edsticas  mencionadas  son  opcionales.  Ud. puede habilitarlas o inhabilitarlas\n       cambiando constantes en el fichero de cabecera del controlador y recompilando.\n\n", "AUTOR": "       Bruce Janson - bruce@cs.usyd.edu.au\n       Jean Tourrilhes - jt@hplb.hpl.hp.com\n       (+ otros - vea el c\u00f3digo fuente para m\u00e1s detalles)\n\nV\u00c9ASE TAMBI\u00c9N\n       wavelan_cs(4), ifconfig(8), insmod(8), iwconfig(8), iwspy(8), iwpriv(8)\n\nUniv. de Sydney (Dpto. CC. C. Basser)                22/X/96                                          WAVELAN(4)\n"},{"NOMBRE": "       null, zero - sumidero de datos\n\n", "DESCRIPCI\u00d3N": "       Los datos escritos en los ficheros especiales null o zero se desechan.\n\n       La lectura del fichero especial null siempre devuelve \"fin de fichero (EOF)\", mientras que la lectura del\n       fichero zero siempre devuelve el caracteres \\0 (NULL).\n\n       null y zero se crean normalmente con:\n\n              mknod -m 666 /dev/null c 1 3\n              mknod -m 666 /dev/zero c 1 5\n              chown root:mem /dev/null /dev/zero\n\n", "OBSERVACIONES": "       Si estos dos ficheros no tienen permiso de lectura y escritura para todos los usuarios, muchos  programas\n       se comportar\u00e1n de manera extra\u00f1a.\n\n", "FICHEROS": "       /dev/null\n       /dev/zero\n\nV\u00c9ASE TAMBI\u00c9N\n       mknod(1), chown(1)\n\nLinux                                             30 Junio 1996                                          NULL(4)\n"}]